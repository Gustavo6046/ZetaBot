version "2.5"

#include "ZetaCode/Standard.zsc"
#include "ZetaCode/Pathing.zsc"
#include "ZetaCode/Appearance.zsc"
#include "ZetaCode/Obstacles.zsc"

// Weapon Modules
#include "ZetaCode/WeaponSupport/ZetaWeapon.zsc"
#include "ZetaCode/WeaponSupport/ZetaBullet.zsc"
#include "ZetaCode/WeaponSupport/ZetaWeaponModule.zsc"
#include "ZetaCode/WeaponSupport/ZetaDoomWeapons.zsc"
#include "ZetaCode/WeaponSupport/ZetaStrifeWeapons.zsc"
#include "ZetaCode/WeaponSupport/ZetaSMWeapons.zsc"

// Pawn Modules
#include "ZetaCode/PawnClasses/ZetaBotPawn.zsc"
#include "ZetaCode/PawnClasses/ZetaDoom.zsc"
#include "ZetaCode/PawnClasses/ZetaStrife.zsc"
#include "ZetaCode/PawnClasses/ZetaSMushes.zsc"

class DestBall : PlasmaBall
{
    Actor targetNode;

    void A_BallTick()
    {
		Vector2 offs = Vec2To(targetNode);
		offs.x /= Distance2D(targetNode);
		offs.y /= Distance2D(targetNode);
		
		Vector2 vel = AngleToVector(angle);

        if ( Distance3D(targetNode) < 72 || (offs.x * vel.x) + (offs.y * vel.y) < 0 )
			SetStateLabel("Death");
    }

	Default
	{
		Damage 0;
	}
    
    States
    {
        Spawn:
            PLSS AB 6 A_BallTick;
            Loop;
    }
}

class WeaponRating : Thinker
{
	double rating;
	bool bAlt;
	
	void BeginPlay()
	{
		rating = 0;
		bAlt = false;
	}
}

class NumBots : Thinker
{
	uint value;

	NumBots Init()
	{
		ChangeStatNum(STAT_INFO);
		value = 0;
		return self;
	}

	static NumBots Get()
	{
		ThinkerIterator it = ThinkerIterator.Create("NumBots", STAT_INFO);
		let p = NumBots(it.Next());
		
		if (p == null)
			p = new("NumBots").Init();
		
		return p;
	}
}

class ZTBotController : Actor
{
    ObstacleCheckWaiter leftObs, frontObs, rightObs;

	enum BotState
	{
		BS_WANDERING = 0,
		BS_HUNTING,
		BS_ATTACKING,
		BS_FOLLOWING,
		BS_FLEEING
	};
	
	enum LogType
	{
		LT_ERROR = 0,
		LT_WARNING,
		LT_INFO,
		LT_VERBOSE
	};

	void DebugLog(LogType kind, string msg)
	{
		if ( CVar.FindCVar("zb_debug").GetInt() > 0 )
		{
			string logHeader = "";
		
			if ( kind == LT_ERROR )
				logHeader = "\cr[ERROR]";
				
			else if ( kind == LT_WARNING )
				logHeader = "\cf[WARNING]";
				
			else if ( kind == LT_INFO )
				logHeader = "\ch[INFO]";
				
			else if ( kind == LT_VERBOSE )
			{
				if ( CVar.FindCVar("zb_debug").GetInt() > 1 )
					logHeader =	"\cd[VERBOSE]";
				
				else
					return;
			}
		
			A_Log("\cq[ZetaBot] "..logHeader.." "..msg);
		}
	}

    bool bReachedGoal;
    ZTPathNode goalNode;
	ZetaBotPawn possessed;
	ZetaWeapon lastWeap;
	BotState bstate;
	ZTPathNode navDest;
	Actor goingAfter;
	Actor enemy;
	Actor commander;
	ZTPathNode currNode;
	double strafeMomentum;
	double angleMomentum;
	double age;
	uint logRate;
	bool initialized;
	double blocked;
	double averageSpeed;
	uint speedRemaining;
	Vector3 lastPos;
	ZTPathNode pastNode;
	int myVoice;
	uint index;
	double lastShot;
	ZetaWeaponModule loader;
	uint botID;
	string myName;
	uint numShoots;
	uint pathCountdown;
	uint retargetCount;
	
	static const string botNames[] = {
		"Jack",
		"Persephone",
		"Ãˆmille",
		"Robert",
		"Amanda",
		"Maria",
		"Mary",
		"Josh",
		"Wagner",
		"John",
		"Louis",
		"Gabriel",
		"Renato",
		"Alejandro",
		"Alexander",
		"Heinrich",
		"Caesar",
		"Walter",
		"Amy",
		"Lawrence",
		"Marylenne",
		"Leonhart",
		"Leonard",
		"Jackson",
		"Lee",
		"Bert",
		"Humberto",
		"Mike",
		"Pablo",
		"Michael",
		"Hitchcock",
		"Hilton",
		"Ronald",
		"Robinson",
		"Son",
		"House",
		"Romulus",
		"Peter",
		"Peterson",
		"Zephyrus",
		"Robin",
		"Paul",
		"Paula",
		"Thorson",
		"Robohead",
		"Minchson",
		"James",
		"Jamilton",
		"Greg",
		"Gregor",
		"Gregory",
		"Victoria",
		"Anita",
		"Whindersson",
		"Melody",
		"Xonon",
		"Xihil"
	};
	
	ZTPathNode RandomGoalNode()
	{
        if ( bReachedGoal )
            return null;
	
        Array<ZTPathNode> goals;
        let iter = ThinkerIterator.Create("ZTPathNode");
        ZTPathNode cur;
        
        while ( cur = ZTPathNode(iter.Next()) )
            if ( cur.bGoalNode )
                goals.Push(cur);
                
        if ( goals.Size() < 1 )
            return null;
                
        return goals[Random(0, goals.Size() - 1)];
	}
	
	override void BeginPlay()
	{
		super.BeginPlay();
		
		if ( CVar.GetCVar('deathmatch').GetInt() == 1 )
			bFRIENDLY = false;

		debugCount = 0;
		retargetCount = 8;
		botID = NumBots.Get().value++;
		age = 0;
		lastShot = -9999;
		numShoots = 0;
	
		loader = ZetaWeaponModule(Spawn("ZetaWeaponModule"));
		
		Array<String> wmodules;
		let tp = CVar.GetCVar("zb_wtypes").GetString();
		tp.Split(wmodules, ";");
		
		for ( int i = 0; i < wmodules.Size(); i++ )
		{
			ZetaWeaponModule zwm = ZetaWeaponModule(Spawn(wmodules[i]));
			loader.LoadModule(zwm);
		}
		
		navDest = null;
		bstate = BS_WANDERING;
		let ptype = ZetaBotPawn.GetSomeType(self);
		
		if ( ptype == "" )
		{
            DebugLog(LT_ERROR, "No plausible pawn type found!");
            Destroy();
            return;
		}
		
        else
            SetPossessed(ZetaBotPawn(Spawn(ptype, pos)));
            
		goingAfter = null;
		currNode = null;
		enemy = null;
		commander = null;
		strafeMomentum = 0;
		angleMomentum = 0;
		blocked = 0;
		averageSpeed = 0;
		speedRemaining = 87;
		pastNode = null;
		initialized = true;
		myVoice = Random(1, 4);
		logRate = 150;
		
		leftObs = ObstacleChecker.MakeFor(self, -45, 8 * Speed);
        frontObs = ObstacleChecker.MakeFor(self, -45, 8 * Speed);
        rightObs = ObstacleChecker.MakeFor(self, -45, 8 * Speed);
		
		myName = botNames[Random(0, botNames.Size() - 1)];
	}
	
	void PlayPain()
	{
		BotChat("PAIN", 0.6);
	}
	
	void aimToward(Actor other, double speed, double threshold = 15)
	{
		aimAtAngle(possessed.AngleTo(other), speed, threshold);
	}
	
	void aimAtAngle(double angle, double speed, double threshold = 15)
	{
		possessed.angle += DeltaAngle(possessed.angle, angle) * speed;
		
		if ( absangle(angle, possessed.angle) <= threshold )
			possessed.angle = angle;
	}
	
	void AimAwayFrom(Actor other, double speed, double threshold = 15)
	{
		AimAtAngle(-possessed.AngleTo(other), speed, threshold);
	}
	
	void SetPossessed(ZetaBotPawn other)
	{
		if ( other != null )
		{
			DebugLog(LT_INFO, myName.." has possessed a "..other.GetClassName().."!");
		
			possessed = other;
			possessed.cont = self;
			
			if ( CVar.GetCVar("deathmatch").GetInt() == 1 )
                other.bFRIENDLY == false;
			
			averageSpeed = 0;
			speedRemaining = 87;
			angleMomentum = 0;
			strafeMomentum = 0;
			enemy = null;
			commander = null;
			goingAfter = null;
			bstate = BS_WANDERING;
			navDest = null;
			blocked = 0;
			lastPos = other.pos;
		}	
	}
	
	void MoveToward(Actor other, double aimSpeed)
	{
		AimToward(other, aimSpeed);
		MoveForward();
		
		if ( possessed.AngleTo(other) > possessed.Angle - 20 )
			MoveRight();
			
		else if ( possessed.Angle + 20 < possessed.AngleTo(other) )
			MoveLeft();
	}
	
	void MoveRight()
	{
		possessed.MoveRight();
	}
	
	void MoveLeft()
	{
		possessed.MoveLeft();
	}
	
	void MoveAwayFrom(Actor other)
	{
		possessed.MoveForward();
		AimAwayFrom(other, 0.07);
	}
	
	void StepBackFrom(Actor other)
	{
		possessed.MoveBackward();
		AimToward(other, 0.085);
	}
	
	void StepBack()
	{
		possessed.StepBackward();
	}

	void CheckObstructions()
	{
        if ( leftObs.st == frontObs.st && frontObs.st == rightObs.st && leftObs.st != ObstacleCheckWaiter.CS_PENDING )
        {
            if ( frontObs != null && frontObs.st == ObstacleCheckWaiter.CS_WALL )
            {
                if ( leftObs.st == ObstacleCheckWaiter.CS_NOTHING )
                    angleMomentum -= 0.2;
                    
                else if ( rightObs.st == ObstacleCheckWaiter.CS_NOTHING )
                    angleMomentum += 0.2;
                    
                else
                    possessed.MoveBackward();
            }
            
            leftObs = ObstacleChecker.MakeFor(self, -45, 5 * Speed);
            frontObs = ObstacleChecker.MakeFor(self, 0, 5 * Speed);
            rightObs = ObstacleChecker.MakeFor(self, 45, 5 * Speed);
        }
	}
	
	ActorList VisibleEnemies(Actor from)
	{
		ActorList res = new("ActorList");
		ThinkerIterator iter = ThinkerIterator.Create("Actor");
		Actor cur = null;
		
		while ( cur = Actor(iter.Next()) )
		{
			Vector2 off = possessed.Vec2To(cur);

			double pdot = 1;

			if ( possessed.Distance2D(cur) > 0 )
			{
				off.x /= possessed.Distance2D(cur);
				off.y /= possessed.Distance2D(cur); // slightly inneficient but works

				Vector2 avec = AngleToVector(possessed.angle);

				double pdot = off.x * avec.x + off.y * avec.y;
			}
			
			if ( cur != null && cur != from && ( cur.bISMONSTER || cur.CheckClass("PlayerPawn", AAPTR_DEFAULT, true) ) && from.CheckSight(cur) && isEnemy(from, cur) && cur.Health > 0 && pdot > 0.3 )
				res.Push(cur);
		}
				
		return res;
	}
	
	ActorList VisibleFriends(Actor from)
	{
		ActorList res = new("ActorList");
		ThinkerIterator iter = ThinkerIterator.Create("Actor");
		Actor cur = null;
		
		while ( cur = Actor(iter.Next()) )
		{
			Vector2 off = possessed.Vec2To(cur);

			double pdot = 1;

			if ( possessed.Distance2D(cur) > 0 )
			{
				off.x /= possessed.Distance2D(cur);
				off.y /= possessed.Distance2D(cur);

				Vector2 avec = AngleToVector(possessed.angle);

				double pdot = off.x * avec.x + off.y * avec.y;
			}

			if ( cur != null && cur != from && cur.Health > 0 && from.CheckSight(cur) && ( ( cur.bISMONSTER && !isEnemy(from, cur) ) || ( cur.CheckClass("PlayerPawn", AAPTR_DEFAULT, true) == from.bFRIENDLY ) ) && pdot > 0.3 )
				res.Push(cur);
		}
				
		return res;
	}

	uint debugCount;
	
	bool MoveTowardDest()
	{
		Actor dest = navDest;
		
		if ( !dest )
			dest = goingAfter;
			
		if ( !dest )
			dest = enemy;
			
		if ( !dest )
			return false;
	
		MakeDestBall(dest);
		MoveToward(dest, 0.2);
		return true;
	}

	void MakeDestBall(Actor Other)
	{
		if ( CVar.FindCVar("zb_debug").GetInt() > 0 && debugCount < 1 )
		{
			debugCount += 10;
			DestBall db = DestBall(possessed.SpawnMissile(Other, "DestBall"));

			if ( db != null )
				db.targetNode = Other;
		}

		else
			debugCount--;
	}
	
	void SmartMove()
	{
		if ( possessed != null )
		{
			if ( navDest != null )
			{
				if ( currNode != null )
				{
					if ( navDest.nodeType == ZTPathNode.NT_JUMP )
					{
						aimToward(navDest, 0.1, 0.1);
					
						if ( possessed.pos.z - possessed.floorz < 1 )
							possessed.Jump();
					}
					
					else if ( navDest.nodeType == navDest.NT_CROUCH )
						possessed.moveType = ZetaBotPawn.MM_Crouch;
						
					else if ( navDest.nodeType == navDest.NT_SLOW )
						possessed.moveType = ZetaBotPawn.MM_None;
						
					else
						possessed.moveType = ZetaBotPawn.MM_Run;
						
					if ( navDest.pos.z - possessed.pos.z > 28 && possessed.pos.z - possessed.floorz < 1 )
						possessed.Jump();
						
					MoveTowardDest();
				}
				
				/* -- no Use function currently
				else
				{
					if ( currNode.nodeType == ZTPathNode.NT_USE )
					{
						double ang = tan(currNode.useDirection.y / currNode.useDirection.x);
						aimAtAngle(ang, 2, 15);
						
						if ( absangle(possessed.angle, ang) < 30 )
							;
					}
				}
				*/
					
				else
					MoveTowardDest();
			}
			
			else
				angleMomentum += FRandom(-0.01, 0.01);
				
				if ( FRandom(0, 99.9) < 10 )
					RandomStrafe();
				
				else
					MoveForward();
		}
	}
	
	void MoveForward()
	{
		possessed.MoveForward();
	}
	
	static const string BStateNames[] = {
		"wandering",
		"hunting",
		"attacking",
		"following",
		"fleeing"
	};
	
	void SetBotState(uint s)
	{
		if ( s != bstate )
            DebugLog(LT_INFO, myName.." is now \ck"..BStateNames[s].."!");
            
		bstate = s;
	}
	
	bool isEnemy(Actor from, Actor other)
	{
		return from.bFRIENDLY != other.bFRIENDLY || ( !from.bFRIENDLY && other.CheckClass("PlayerPawn", AAPTR_DEFAULT, true) ) || CVar.GetCVar("deathmatch").GetInt() == 1;
	}
	
	ZTPathNode ClosestNode(Actor other)
	{
		ThinkerIterator iter = ThinkerIterator.Create("ZTPathNode");
		ZTPathNode best = null;
		ZTPathNode cur = null;
		
		while ( cur = ZTPathNode(iter.Next()) )
			if ( best == null || other.Distance3D(cur) < other.Distance3D(best) )
				best = cur;
				
		return best;
	}
	
	void RandomStrafe()
	{
		strafeMomentum += FRandom(-0.1, 0.1);
		
		if ( strafeMomentum < -1 ) 
			strafeMomentum = -1;
			
		if ( strafeMomentum > 1 ) 
			strafeMomentum = 1;
			
		if ( strafeMomentum > 0 )
			possessed.MoveRight();
			
		else
			possessed.MoveLeft();
	}
	
	BotState assessBotAttitude(Actor other) // mimicks UT99's TournamentGameInfo(?).AssessBotAttitude(Pawn Other)
	{
		if ( isEnemy(possessed, other) )
			return BS_ATTACKING;
			
		else
			return BS_WANDERING;
	}
	
	ZetaWeapon, bool BestWeaponAllTic()
	{
		double bestRate = 0;
		bool bAltFire = false;
		ZetaWeapon zweap = null;
		ZetaWeapon bestWeap = null;
		Weapon weap = null;
		let iter = ThinkerIterator.create("Weapon");
		
		while ( weap = Weapon(iter.Next()) )
            if ( weap.Owner == possessed )
            {
                ZetaWeapon zweap = loader.CheckType(weap);
                // A_Log(myName.." > "..weap.GetClassName());
            
                if ( zweap != null )
                {
                    let assessed1 = zweap.RateSelf(self, enemy);
                    let assessed2 = zweap.AltRateSelf(self, enemy);
                    let alt = zweap.CanAltFire(possessed) && assessed2 > assessed1;
                    
                    if ( !(alt || zweap.CanFire(possessed))  )
                        continue;
                    
                    let maxAssessed = alt ? assessed1 : assessed2;
                
                    // A_Log("("..zweap.GetClassName().." -> "..maxAssessed..")");
                
                    if ( bestWeap == null || maxAssessed > bestRate )
                    {
                        bestRate = maxAssessed;
                        bestWeap = zweap;
                        bAltFire = alt;
                    }
                }
            }
		
		return bestWeap, bAltFire;
	}

	ZetaWeapon, bool BestWeapon()
	{
		double bestRate = 0;
		bool bAltFire = false;
		ZetaWeapon zweap = null;
		ZetaWeapon bestWeap = null;
		Weapon weap = null;
		let iter = ThinkerIterator.create("Weapon");
		
		while ( weap = Weapon(iter.Next()) )
		{
			ZetaWeapon zweap = loader.CheckType(weap);
		
			if ( weap.Owner == possessed && zweap != null && zweap.CanFire(possessed) )
			{
				let assessed1 = zweap.RateSelf(self, enemy);
				let assessed2 = zweap.AltRateSelf(self, enemy);
				let alt = zweap.CanAltFire(possessed) && assessed2 > assessed1;
                
                if ( !(alt || zweap.CanFire(possessed))  )
                    continue;
                
				let maxAssessed = alt ? assessed1 : assessed2;
			
				if ( ( age - lastShot > zweap.AltIntervalSeconds() || !alt ) && ( age - lastShot > zweap.IntervalSeconds() || alt ) && ( bestWeap == null || maxAssessed > bestRate ) )
				{
					bestRate = maxAssessed;
					bestWeap = zweap;
					bAltFire = alt;
				}
			}
		}
		
		return bestWeap, bAltFire;
	}
	
	bool FireBestWeapon()
	{
        if ( lastWeap != null && BestWeaponAllTic() == lastWeap ) // to avoid switching down weapons due to age - lastShot
        {
            if ( lastWeap.CanAltFire(possessed) && lastWeap.AltRateSelf(self, enemy) > lastWeap.RateSelf(self, enemy) )
            {
                if ( age - lastShot > lastWeap.AltIntervalSeconds() )
                {
                    // A_Log(lastWeap.GetClassName());
                    lastWeap.AltFire(possessed, enemy);
                    lastShot = age;
                }
                    
                return age - lastShot > lastWeap.AltIntervalSeconds();
            }
            
            if ( lastWeap.CanFire(possessed) )
            {
                if ( age - lastShot > lastWeap.IntervalSeconds() )
                {
                    // A_Log(lastWeap.GetClassName());
                    lastWeap.Fire(possessed, enemy);
                    lastShot = age;
                }
                    
                return age - lastShot > lastWeap.IntervalSeconds();
            }
        }
    
		ZetaWeapon bestWeap;
		bool bAltFire;
		
		[ bestWeap, bAltFire ] = BestWeaponAllTic();
        
		if ( bestWeap == null )
			return false;
		
		if ( bAltFire && bestWeap.CanAltFire(possessed, true) && age - lastShot > bestWeap.AltIntervalSeconds() )
			bestWeap.AltFire(possessed, enemy);
			
		else if ( bestWeap.CanFire(possessed, true) && age - lastShot > bestWeap.IntervalSeconds() )
			bestWeap.Fire(possessed, enemy);
            
        else
            return false;

        // A_Log(bestWeap.GetClassName());
            
        numShoots++;
			
		lastShot = age;
        lastWeap = bestWeap;
			
		return true;
	}
	
	/* -- unused
	virtual WeaponRating rateWeapon(Weapon weap)
	{
		WeaponRating res = new("WeaponRating");
		
		if ( target == null )
		{
			res.rating = 0;
			res.bAlt = false;
			return res;
		}
	
		double rprimary = 0;
		double raltern  = 0;
		double rboth    = 0;
	
		if ( possessed.Distance3D(enemy) < target.radius + radius + 256 )
			rboth += weap.Kickback * 4;
			
		if ( weap.ProjectileType != null )
		{
			let proj = Spawn(weap.ProjectileType);
			rprimary += proj.speed * possessed.Distance3D(enemy) + proj.damage;
			proj.Destroy();
		}
		
		else
		{
			double rangeRate = 1024;
			rangeRate -= possessed.Distance3D(enemy) / 2;
			
			if ( rangeRate > 0 )
				rprimary += rangeRate;
		}
		
		if ( weap.AltProjectileType != null )
		{
			let proj = Spawn(weap.AltProjectileType);
			raltern += proj.speed * possessed.Distance3D(enemy) + proj.damage;
			proj.Destroy();
		}
		
		else
		{
			double rangeRate = 1024;
			rangeRate -= possessed.Distance3D(enemy) / 2;
			
			if ( rangeRate > 0 )
				raltern += rangeRate;
		}
		
		Inventory ammo1 = FindInventory(weap.AmmoType1);
		Inventory ammo2 = FindInventory(weap.AmmoType2);
		
		if ( ammo1 != null )
			rboth += ammo1.Amount * 2;
			
		if ( ammo2 != null )
			rboth += ammo2.Amount * 2;
		
		if ( raltern > rprimary )
		{
			res.rating = raltern + rboth;
			res.bAlt = true;
		}
		
		else
		{
			res.rating = rprimary + rboth;
			res.bAlt = false;
		}
		
		return res;
	}
	*/
	
	void BotChat(String kind, double importance)
	{
		if ( importance < FRandom(0, 9.9999) )
			return;
	
		A_PlaySound("zetabot/"..myVoice.."/"..kind, CHAN_VOICE, attenuation: 0.7);
		A_PlaySound("misc/chat", CHAN_UI, 1.0, false, ATTN_NONE);
	}
	
	double targetPriority(Actor other)
	{
		// The smalest the number, the highest the priority :)
		double res = possessed.Distance3D(other) / other.Health;

		if ( other.CheckClass('PlayerPawn') )
			res /= 1.5;

		return res;
	}
	
	void LogStats()
	{
		if ( possessed == null )
			return;
			
		String enemyType = "NONE";
		String goingAfterType = "NONE";
		String currNodeS = "NONE";
		String navDestS = "NONE";
		
		if ( enemy != null )
			enemyType = enemy.GetClassName();
			
		if ( goingAfter != null )
			goingAfterType = goingAfter.GetClassName();
		
		if ( currNode != null )
			currNodeS = currNode.serialize();
			
		if ( navDest != null )
			navDestS = navDest.serialize();
	
		DebugLog(LT_VERBOSE, "["..myName.."'s STATS] Health: "..possessed.health.." | Current State: "..BStateNames[bstate].." | Enemy Type: "..enemyType.." | Going After Type: "..goingAfterType.." | Current Pathnode: "..currNodeS.." | Destination Pathnode: "..navDestS.." | Age: "..age.."s");
	}
	
	// bot death listener
	void OnDeath()
	{
		A_PrintBold("\cg"..myName.." has just died!");
		
		let friends = VisibleFriends(possessed);
		Object a = null;
		ZetaBotPawn zb = null;
		
		while ( a = friends.iNext() )
            if ( (zb = ZetaBotPawn(a)) && possessed.Distance3D(zb) < 2048 / friends.Length() && zb.cont.bState == BS_ATTACKING && zb.cont != null )
                zb.cont.SetBotState(BS_FLEEING);
                
        NumBots.Get().value--;
	}
	
	void A_BotTick()
	{
		possessed.angle += angleMomentum;
		angleMomentum *= 0.92;
		
		if ( possessed == null )
			return;
		
		if ( possessed.health <= 0 )
			return;
			
		age += 1. / 35;
			
		if ( age - lastShot > 0.7 && possessed.bShooting )
			possessed.EndShoot();
			
		currNode = ClosestNode(possessed);
		
		if ( --logRate <= 0 )
		{
			logRate = 50;
			LogStats();
		}
		
		if ( possessed.blockingMobj != null || possessed.blockingLine != null )
			blocked += sqrt(possessed.vel.x * possessed.vel.x + possessed.vel.y * possessed.vel.y) / 2;
			
		if ( blocked > 0 )
		{
			blocked--;
			RandomStrafe();
			possessed.angle += 3;
			
			return;
		}
		
		let pickupIter = ThinkerIterator.Create("Weapon");
		Weapon inv;
		
		while ( (inv = Weapon(pickupIter.Next())) != null )
			if ( inv.owner == null && possessed.Distance2D(inv) < possessed.Radius + inv.Radius && abs(possessed.pos.z - inv.pos.z) < possessed.Height + inv.Height )
			{
				ZetaWeapon zw = loader.CheckType(inv);
			
				if ( zw != null )	
					inv.CallTryPickup(possessed); // weapon items are checked by fireBestWeap
					
				else
					if ( inv.CheckClass("HealthPickup") || inv.CheckClass("Ammo") )
						inv.CallTryPickup(possessed);
			}

		if ( bstate != BS_ATTACKING )
		{
            if ( bstate != BS_HUNTING && bstate != BS_FLEEING )
            {
                ActorList mon = VisibleEnemies(possessed);
			
                if ( mon.length() > 0 )
                {
                    PriorityQueue targets = new("PriorityQueue");
                
                    for ( uint i = 0; i < mon.length(); i++ )
                        targets.add(mon.get(i), TargetPriority(mon.get(i)));
                
                    if ( bstate != BS_ATTACKING || enemy == null )
                        enemy = Actor(targets.poll());

                    else
                    {
                        if ( retargetCount < 1 )
                        {
                            enemy = Actor(targets.poll());
                            retargetCount = 15;
                        }

                        else
                            retargetCount--;
                    }

                    DebugLog(LT_INFO, "Attacking a "..enemy.GetClassName());
                    
                    BotChat("TARG", 0.5);
                    
                    if ( possessed.Distance3D(enemy) > 1024 && ClosestNode(enemy) != currNode )
                    {
                        goingAfter = enemy;
                        SetBotState(BS_HUNTING);
                    }
                        
                    else
                        SetBotState(BS_ATTACKING);
                        
                    return;
                }
            }
        
			if ( navDest != null )
			{
				if ( possessed.Distance3D(navDest) > 64 )
					SmartMove();
					
				else if ( bstate == BS_WANDERING )
					navDest = navDest.randomNeighbor();
					
				else
					navDest = null;
			}
			
			else
			{
				if ( bstate == BS_HUNTING || bstate == BS_FOLLOWING )
				{
					if ( goingAfter != null )
					{
						if ( possessed.Distance3D(goingAfter) < 1024 && possessed.CheckSight(goingAfter) )
							SetBotState(AssessBotAttitude(goingAfter));
					
						else if ( currNode != null && ( navDest == null || Distance3D(navDest) < 512 || navDest == currNode ) )
						{
							if ( ClosestNode(goingAfter) == currNode )
                            {
                                if ( possessed.Distance3D(goingAfter) < 256 )
                                    SetBotState(BS_ATTACKING);
                                        
                                else if ( possessed.Distance3D(goingAfter) > 5192 && !possessed.CheckSight(goingAfter) )
                                    SetBotState(BS_WANDERING);
                            }
								
							else if ( pathCountdown <= 0 )
							{
								ActorList path = navDest.findPathTo(ClosestNode(goingAfter), possessed);
								
								if ( path != null && path.Length() > 1 )
								{
									navDest = ZTPathNode(path.get(1));
									
									DebugLog(LT_INFO, "Next navigation point found at: "..navDest.pos);
									MoveToward(navDest, 0.27);
								}
									
								else if ( possessed.Distance3D(goingAfter) < 256 && possessed.CheckSight(goingAfter) )
									SetBotState(BS_WANDERING);
									
								else
									MoveToward(goingAfter, 0.27);

								pathCountdown += 15;
							}

							else
								pathCountdown--;
						}
						
						else if ( navDest != null )
							SmartMove();
						
						else if ( possessed.Distance3D(goingAfter) < 256 )
							SetBotState(BS_ATTACKING);
								
						else if ( possessed.Distance3D(goingAfter) > 1500 && !possessed.CheckSight(goingAfter) )
							SetBotState(BS_WANDERING);
							
						else
							MoveToward(goingAfter, 0.27);
					}
					
					else
						SetBotState(BS_WANDERING);
				}
				
				else if ( bstate == BS_FLEEING )
				{
					if ( enemy != null )
						MoveAwayFrom(enemy);
					
					else
						SetBotState(BS_WANDERING);
				}
				
				else if ( bstate == BS_WANDERING )
				{
                    if ( currNode == goalNode )
                        bReachedGoal == true;
				
                    else if ( !bReachedGoal )
                    {
                        if ( goalNode == null )
                        {
                            goingAfter = goalNode = RandomGoalNode();
                            
                            if ( goalNode != null )
                            {
                                SetBotState(BS_FOLLOWING);
                                return;
                            }
                        }
                        
                        else if ( !CheckSight(goalNode) )
                        {
                            goingAfter = goalNode;
                            SetBotState(BS_FOLLOWING);
                            return;
                        }
                        
                        else
                            MoveToward(goalNode, 0.6);
                    }
                        
				
					MoveForward();
					
					if ( commander != null && ( possessed.Distance3D(commander) > 1024 && !possessed.CheckSight(commander) ) && ClosestNode(commander) != currNode )
					{
						SetBotState(BS_FOLLOWING);
						goingAfter = commander;
					}
				
					else if ( commander == null )
					{ // get a commander
						ActorList friends = VisibleFriends(possessed);
						
						if ( friends.length() > 0 )
						{
                            commander = friends.get(Random(0, friends.length() - 1));
                            
                            if ( !commander.CheckClass("ZetaBotPawn", AAPTR_DEFAULT, true) )
                            {
                                let ztcom = ZetaBotPawn(commander);
                                
                                if ( ztcom == null || ztcom.cont == null )
                                    DebugLog(LT_INFO, myName.." is now following a "..commander.GetClassName());
                                    
                                else
                                    DebugLog(LT_INFO, myName.." is now following "..ztcom.cont.myName);
							}
							
							BotChat("COMM", 0.8);
						}
					}
				
					if ( commander == null )
					{ // wander around
						if ( currNode == null )
							currNode = ClosestNode(self);
							
						ZTPathNode ng = null;
					
						if ( currNode != null && (ng = currNode.RandomNeighbor()) != currNode && ng != null )
							MoveToward(ng, 0.12); // wander to a random 'neighboring' node
						
						else
						{ // just wander around :P
							
							angleMomentum += FRandom(-0.04, 0.04);
							
							if ( FRandom(0, 1) < 0.7 )
								MoveForward();
							
							else if ( FRandom(0, 1) < 0.5 )
								RandomStrafe();
								
							else
								StepBack();
							
							BotChat("IDLE", 0.1);
						}
					}
				
					/*
					if ( currNode == null || possessed.Distance3D(currNode) > 768 )
						currNode = ZTPathNode.plopNode(pos, ZTPathNode.NT_NORMAL);
					*/
				}
			}
		}
			
		else
		{
			if ( enemy != null && enemy.Health > 0 )
			{
				if ( possessed.Distance3D(enemy) > 1500 && ClosestNode(enemy) != currNode )
				{
					possessed.EndShoot();
                    goingAfter = enemy;
					SetBotState(BS_HUNTING);
				}
				
                /* - our bots can't be cowards
				else if ( possessed.Health < possessed.default.Health / 9 + 4 )
				{
					possessed.EndShoot();
					SetBotState(BS_FLEEING);
				}
                */
				
				else
				{
					if ( FRandom(0, 1) < 0.2 )
						possessed.Jump();
				
					BotChat("ACTV", 0.08);
						
					ZetaWeapon w = BestWeapon();
					// MakeDestBall(enemy);

					if ( BestWeaponAllTic() == null )
					{
						SetBotState(BS_FLEEING);
						return;
					}

					if ( possessed.Distance3D(enemy) > 256 + enemy.radius || ( w != null && w.IsMelee() ) )
						MoveToward(enemy, 0.282);
						
					else if ( possessed.Distance3D(enemy) < 128 + enemy.radius )
						StepBackFrom(enemy);
						
					RandomStrafe();
					AimToward(enemy, 0.27, 30);
					
					if ( fireBestWeapon() )
						possessed.BeginShoot();
						
					else
						possessed.EndShoot();
				}
			}
			
			else
			{
                BotChat("ELIM", 0.9);
                
                enemy = null;
                goingAfter = null;

				possessed.EndShoot();
				SetBotState(BS_WANDERING);
			}
		}
		
		if ( currNode == null || possessed.Distance2D(currNode) > 512 )
		{
			pastNode = currNode;
			currNode = ZTPathNode.plopNode(possessed.pos, ZTPathNode.NT_NORMAL);
		}
		
		if ( angleMomentum > 1.28 )
			angleMomentum = 1.28;
			
		if ( angleMomentum < -1.28 )
			angleMomentum = -1.28;
	}

	States
	{
		Spawn:
			TNT1 A 1;
			Goto TickLoop;
			
		TickLoop:
			TNT1 A 1 A_BotTick;
			Loop;
	}
}

class ZetaBot : Actor
{
	enum LogType
	{
		LT_ERROR = 0,
		LT_WARNING,
		LT_INFO,
		LT_VERBOSE
	};

	void DebugLog(LogType kind, string msg)
	{
		if ( CVar.FindCVar("zb_debug").GetInt() > 0 )
		{
			string logHeader = "";
		
			if ( kind == LT_ERROR )
				logHeader = "\cr[ERROR]";
				
			else if ( kind == LT_WARNING )
				logHeader = "\cf[WARNING]";
				
			else if ( kind == LT_INFO )
				logHeader = "\ch[INFO]";
				
			else if ( kind == LT_VERBOSE )
			{
				if ( CVar.FindCVar("zb_debug").GetInt() > 1 )
					logHeader =	"\cd[VERBOSE]";
				
				else
					return;
			}
		
			A_Log("\cq[ZetaBot] "..logHeader.." "..msg);
		}
	}
	
	uint botID;

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		bool bHasNode;
		let ni = ThinkerIterator.create("ZTPathNode");
		
		if ( ni.Next() )
			bHasNode = true;
			
		if ( !bHasNode && CVar.FindCVar("nodelist").GetString() != "::NONE" )
			ZTPathNode.plopNodes(CVar.FindCVar("nodelist").GetString());
			
		DebugLog(LT_VERBOSE, "Serialized Nodes: "..ZTPathNode.serializeLevel());
	
		ZTBotController cont = ZTBotController(Spawn("ZTBotController", pos));
		
		if ( cont == null )
            return;
		
		ZetaCape.MakeFor(cont.possessed);
		cont.possessed.angle = angle;
		
		DebugLog(LT_INFO, "ZetaBot spawned with success! Class: "..cont.possessed.GetClassName());
		Destroy();
	}
}

class BotName : Inventory
{
    int countDown;

    override void BeginPlay()
    {
        super.BeginPlay();
        countDown = 0;
    }
    
    override void Tick()
    {
        if ( countDown < 1 )
        {
            let iter = ThinkerIterator.Create("ZetaBotPawn");
            ZetaBotPawn zb = null;
            ZetaBotPawn closest = null;
            double cdist = 0;
            
            while ( zb = ZetaBotPawn(iter.Next()) )
            {
                Vector2 v1 = AngleToVector(Owner.angle);
                Vector2 v2 = Owner.Vec2To(zb) / Owner.Distance2D(zb);
                
                double vdot = (v1.x * v2.x + v1.y * v2.y);
                
                /*
                if ( zb.cont == null )
                    Log(zb.GetClassName()..": "..vdot..", "..Owner.Distance2D(zb));
                    
                else
                    Log(zb.cont.myName..": "..vdot..", "..Owner.Distance2D(zb));
                */
                
                if ( vdot > 1 - 1 / (Owner.Distance2D(zb) / (zb.Radius + 4)) && Owner.CheckSight(zb) && zb.cont != null && zb.Health > 0 && ( closest == null || Owner.Distance2D(zb) < cdist ) ) 
                {
                    cdist = Owner.Distance2D(zb);
                    closest = zb;
                }
            }
            
            if ( closest != null )
            {
                Owner.A_Print("\ci"..closest.cont.myName);
                countDown = 3;
            }
                
            else
                countDown = 2;
        }
            
        else
            countDown--;
    }
}
