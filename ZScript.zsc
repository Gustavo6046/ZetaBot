version "2.5"

#include "ZetaCode/Standard.zsc"
#include "ZetaCode/Pathing.zsc"
#include "ZetaCode/Appearance.zsc"

// Weapon Modules
#include "ZetaCode/WeaponSupport/ZetaWeapon.zsc"
#include "ZetaCode/WeaponSupport/ZetaBullet.zsc"
#include "ZetaCode/WeaponSupport/ZetaWeaponModule.zsc"
#include "ZetaCode/WeaponSupport/ZetaDoomWeapons.zsc"
#include "ZetaCode/WeaponSupport/ZetaStrifeWeapons.zsc"
#include "ZetaCode/WeaponSupport/ZetaHereticWeapons.zsc"
#include "ZetaCode/WeaponSupport/ZetaSMWeapons.zsc"

// Pawn Modules
#include "ZetaCode/PawnClasses/ZetaBotPawn.zsc"
#include "ZetaCode/PawnClasses/ZetaDoom.zsc"
#include "ZetaCode/PawnClasses/ZetaHeretic.zsc"
#include "ZetaCode/PawnClasses/ZetaStrife.zsc"
#include "ZetaCode/PawnClasses/ZetaSMushes.zsc"



class ZTBotOrder : Actor {
    Actor orderer;
    Actor lookedAt;
    String v_imperative, v_past, v_continuous;
    uint orderType;

    static const String BStateImperative[] = {
        "wander",
        "hunt",
        "attack",
        "follow",
        "flee"
    };

    static const String BStatePast[] = {
        "wandered",
        "hunted",
        "attacked",
        "followed",
        "fled"
    };

    static const String BStateContinuous[] = {
        "wandering",
        "hunting",
        "attacking",
        "following",
        "chickening"
    };

    override void BeginPlay() {
        lookedAt = null;

        v_imperative = "do";
        v_past = "did";
        v_continuous = "doing";

        orderType = ZTBotController.BS_WANDERING;
    }

    void Apply(ZTBotController bot) {
        if (lookedAt == null && orderType != ZTBotController.BS_WANDERING) {
            bot.DebugLog(ZTBotController.LT_WARNING, "Can't apply non-wander order without a target!");
            return;
        }

        if (lookedAt == bot.possessed) {
            bot.DebugLog(ZTBotController.LT_WARNING, String.format("Can't order one to %s oneself!", BStateImperative[orderType]));
            return;
        }

        bot.commander = orderer;
        bot.goingAfter = lookedAt;

        if (orderType == ZTBotController.BS_ATTACKING || orderType == ZTBotController.BS_HUNTING) {
            bot.enemy = lookedAt;
        }

        bot.ConsiderSetBotState(orderType);
        bot.SetOrder(self);
    }

    static ZTBotOrder Make(Actor i_orderer, Actor i_lookedAt, uint i_orderType) {
        ZTBotOrder res = ZTBotOrder(Spawn("ZTBotOrder"));

        res.orderer = i_orderer;
        res.lookedAt = i_lookedAt;
        res.orderType = i_orderType;

        res.v_imperative = ZTBotOrder.BStateImperative[i_orderType];
        res.v_past = ZTBotOrder.BStatePast[i_orderType];
        res.v_continuous = ZTBotOrder.BStateContinuous[i_orderType];

        return res;
    }
}

class ZTLineUseHistoryEntry {
    Line Used;
    double When; // zetabot age in seconds
}

class DestBall : PlasmaBall {
    Actor targetNode;

    void A_BallTick() {
        Vector2 offs = Vec2To(targetNode);
        offs.x /= Distance2D(targetNode);
        offs.y /= Distance2D(targetNode);
        
        Vector2 vel = AngleToVector(angle);

        if (Distance3D(targetNode) < 72 || (offs.x * vel.x) + (offs.y * vel.y) < 0)
            SetStateLabel("Death");
    }

    Default {
        Damage 0;
    }
    
    States {
        Spawn:
            PLSS AB 6 A_BallTick;
            Loop;
    }
}

class WeaponRating : Actor {
    double rating;
    bool bAlt;
    
    override void BeginPlay() {
        rating = 0;
        bAlt = false;
    }
}

class NumBots : Thinker {
    uint value;

    NumBots Init() {
        ChangeStatNum(STAT_INFO);
        value = 0;
        return self;
    }

    static NumBots Get() {
        ThinkerIterator it = ThinkerIterator.Create("NumBots", STAT_INFO);
        let p = NumBots(it.Next());
        
        if (p == null)
            p = new("NumBots").Init();
        
        return p;
    }
}

class ZTBotController : Actor {   
    static uint MaxID() {
        ThinkerIterator it = ThinkerIterator.Create("ZTBotController", STAT_DEFAULT);
        uint resMax = 0;
        ZTBotController p;

        while (p = ZTBotController(it.Next()))
            if (p.BotID > resMax)
                resMax = p.BotID;

        return resMax;
    }

    enum BotState {
        BS_WANDERING = 0,
        BS_HUNTING,
        BS_ATTACKING,
        BS_FOLLOWING,
        BS_FLEEING
    };
    
    enum LogType {
        LT_ERROR = 0,
        LT_WARNING,
        LT_INFO,
        LT_VERBOSE
    };

    void DebugLog(LogType kind, String msg) {
        if (CVar.FindCVar("zb_debug").GetInt() > 0) {
            String logHeader = "";
        
            if (kind == LT_ERROR)
                logHeader = "\cr[ERROR]";
                
            else if (kind == LT_WARNING)
                logHeader = "\cf[WARNING]";
                
            else if (kind == LT_INFO)
                logHeader = "\ch[INFO]";
                
            else if (kind == LT_VERBOSE) {
                if (CVar.FindCVar("zb_debug").GetInt() > 1)
                    logHeader =	"\cd[VERBOSE]";
                
                else
                    return;
            }
        
            A_Log("\cq[ZetaBot] "..logHeader.." "..msg);
        }
    }

    ZetaBotPawn possessed;
    ZetaWeapon lastWeap;
    BotState bstate;
    ZTPathNode navDest;
    Actor goingAfter;
    Actor enemy;
    Actor commander;
    ZTPathNode currNode;
    double strafeMomentum;
    double angleMomentum;
    ZTPathNode lastEnemyPos;
    double age;
    uint GruntInterval;
    uint logRate;
    uint BotID;
    uint TelefragTimer;
    bool initialized;
    double blocked;
    double averageSpeed;
    uint speedRemaining;
    Vector3 lastPos;
    ZTPathNode pastNode;
    int myVoice;
    uint index;
    double lastShot;
    ZetaWeaponModule loader;
    String myName;
    uint numShoots;
    uint pathCountdown;
    uint retargetCount;
    Array<ZTLineUseHistoryEntry> UseHistory;
    
    bool AutoUseAtAngle(double angle) {
        FLineTraceData td;

        possessed.LineTrace(
            possessed.angle + angle,
            possessed.radius + 64,
            0,
            flags: TRF_THRUBLOCK | TRF_THRUHITSCAN | TRF_THRUACTORS,
            offsetz: possessed.height - 24,
            data: td
        );

        if (td.HitType != TRACE_HitWall)
            return false;

        if (td.HitLine.Special == 0) {
            if (GruntInterval == 0 || GruntInterval-- == 0) {
                possessed.A_PlaySound("ztmisc/grunt", CHAN_VOICE, attenuation: 1.1);
                GruntInterval = 20;
                Log(GruntInterval);

                if (currNode != null) {
                    MoveAwayFrom(currNode);
                    MoveAwayFrom(currNode);
                }
            }

            return false;
        }

        for (let i = 0; i < UseHistory.Size(); i++) {
            if (UseHistory[i].Used == td.HitLine && age - UseHistory[i].When < CVar.FindCVar('zb_autouseinterval').GetFloat())
                return false;

            else if (age - UseHistory[i].When >= CVar.FindCVar('zb_autouseinterval').GetFloat())
                UseHistory.Delete(i--);
        }

        Line l = td.HitLine;
        DebugLog(LT_VERBOSE, "["..myName.." USE NODE LOGS] Auto-activating wall! Line special: "..l.Special);
        l.Activate(possessed, 0, SPAC_Use);

        Level.ExecuteSpecial(
            l.Special,
            possessed,
            l, 0,

            l.Args[0],
            l.Args[1],
            l.Args[2],
            l.Args[3],
            l.Args[4]
        );

        if (CVar.FindCVar('zb_autonodes').GetBool()) {
            SetCurrentNode(ZTPathNode.plopNode(pos, ZTPathNode.NT_USE, possessed.angle));
            currNode.Angle = Angle; 
        }

        ZTLineUseHistoryEntry entry = new("ZTLineUseHistoryEntry");

        entry.Used = td.HitLine;
        entry.When = age;

        UseHistory.Push(entry);

        return true;
    }

    override void BeginPlay() {
        super.BeginPlay();

        GruntInterval = 0;
        TelefragTimer = 17;
        
        if (CVar.FindCVar('deathmatch').GetInt() > 0)
            bFRIENDLY = false;

        debugCount = 0;
        retargetCount = 8;
        NumBots.Get().value++;
        BotID = MaxID();
        age = 0;
        lastShot = -9999;
        numShoots = 0;
    
        loader = ZetaWeaponModule(Spawn("ZetaWeaponModule"));
        
        Array<String> wmodules;
        let tp = CVar.FindCVar("zb_wtypes").GetString();
        tp.Split(wmodules, ";");
        
        for (int i = 0; i < wmodules.Size(); i++) {
            ZetaWeaponModule zwm = ZetaWeaponModule(Spawn(wmodules[i]));
            uint oldLoaded = loader.weaponsLoaded.Size();
            loader.LoadModule(zwm);
            DebugLog(LT_VERBOSE, String.Format("Loaded weapons module: %s (%i weapons)", zwm.GetClassName(), loader.weaponsLoaded.Size() - oldLoaded));
        }
        
        navDest = null;
        bstate = BS_WANDERING;
        let ptype = ZetaBotPawn.GetSomeType(self);
        
        if (ptype == "") {
            DebugLog(LT_ERROR, "No plausible pawn type found!");
            Destroy();
            return;
        }
        
        else {
            DebugLog(LT_INFO, String.Format("Type chosen: %s", ptype));
            SetPossessed(ZetaBotPawn(Spawn(ptype, pos)));

            // Telefrag overlaps
            let telefragIter = ThinkerIterator.Create("Actor", STAT_DEFAULT);
            Actor mon = null;

            while (mon = Actor(telefragIter.Next())) {
                if (mon.Distance2D(possessed) <= mon.Radius + possessed.Radius && mon != possessed) {
                    if (ZetaBotPawn(mon) == null || ZetaBotPawn(mon).cont.TelefragTimer == 0) {
                        uint tries = 20; // for things that absorb less damage
                        uint damage = mon.Health;

                        for (; tries > 0 && mon.Health > 0; tries--)
                            mon.DamageMobj(possessed, possessed, damage, 'Telefrag', DMG_NO_ARMOR | DMG_NO_PROTECT);
                    }
                }
            }
        }
            
        goingAfter = null;
        currNode = null;
        enemy = null;
        commander = null;
        strafeMomentum = 0;
        angleMomentum = 0;
        blocked = 0;
        averageSpeed = 0;
        speedRemaining = 87;
        pastNode = null;
        initialized = true;
        myVoice = Random(1, 4);
        logRate = 150;

        Array<String> botNames;
        CVar.FindCVar('zb_names').GetString().Split(botNames, ',');

        myName = botNames[Random(0, botNames.Size() - 1)];
    }
    
    void PlayPain() {
        if (Health > 0)
            BotChat("HURT", 0.7);
    }
    
    void aimToward(Actor other, double speed, double threshold = 5) {
        aimAtAngle(possessed.AngleTo(other), speed, threshold);
    }
    
    void aimAtAngle(double angle, double speed, double threshold = 5) {
        possessed.angle += DeltaAngle(possessed.angle, angle) * speed / 15;
        
        if (absangle(angle, possessed.angle) <= threshold)
            possessed.angle = angle;
    }
    
    void AimAwayFrom(Actor other, double speed, double threshold = 5) {
        AimAtAngle(-possessed.AngleTo(other), speed, threshold);
    }
    
    Class<ZetaBotPawn> possessedType;

    void A_ZetaRespawn() {
        if (possessedType == null) return;

        ZTPathNode pn, chosen = null;
        double chanceDenom = 1;
        uint found = 0;

        // Find a pathnode where to respawn at
        let iter = ThinkerIterator.Create("ZTPathNode", 91);

        while ((pn = ZTPathNode(iter.Next())) != null) {
            if (pn.nodeType == ZTPathNode.NT_RESPAWN || (CVar.FindCVar("zb_anynoderespawn").GetBool() && pn.nodeType != ZTPathNode.NT_USE && pn.nodeType != ZTPathNode.NT_AVOID)) {
                pn.A_SetSize(possessed.Radius, possessed.Height);

                if (pn.CheckBlock()) {
                    pn.A_SetSize(pn.default.Radius, pn.default.Height);
                    continue;
                }

                double prob = FRandom(0, chanceDenom);

                if (prob <= 1.0)
                    chosen = pn;

                // DebugLog(LT_VERBOSE, String.format("Node %i at x=%f,y=%f has luck value %f/%f.", ++found, pn.pos.x, pn.pos.y, 0 - prob, chanceDenom));
            
                chanceDenom++;
            }
        }

        if (chosen == null) return;

        // Perform the respawn
        Vector3 spawnPos = chosen.pos;
        spawnPos.x += FRandom(-16, 16);
        spawnPos.y += FRandom(-16, 16);

        SetPossessed(ZetaBotPawn(Spawn(possessedType, spawnPos)));
        possessed.angle = chosen.angle;
        SpawnTeleportFog(spawnPos, false, false);

        // Telefrag things
        let telefragIter = ThinkerIterator.Create("Actor", STAT_DEFAULT);
        Actor mon = null;

        while (mon = Actor(telefragIter.Next())) {
            if (mon.Distance2D(chosen) <= mon.Radius + possessed.Radius && mon != possessed) {
                uint tries = 20; // for things that absorb less damage
                uint damage = mon.Health;

                for (; tries > 0 && mon.Health > 0; tries--)
                    mon.DamageMobj(possessed, possessed, damage, 'Telefrag', DMG_NO_ARMOR | DMG_NO_PROTECT);
            }
        }

        TelefragTimer = 17;

        DebugLog(LT_VERBOSE, String.format("%s respawned!", myName));
    }

    void SetPossessed(ZetaBotPawn other) {
        if (other != null) {
            DebugLog(LT_INFO, myName.." has possessed a "..other.GetClassName().."!");
        
            possessed = other;
            ZetaCape.MakeFor(other);
            possessedType = possessed.GetClass();
            possessed.cont = self;
            
            if (CVar.FindCVar("deathmatch").GetInt() == 1)
                other.bFRIENDLY == false;
            
            averageSpeed = 0;
            speedRemaining = 87;
            angleMomentum = 0;
            strafeMomentum = 0;
            enemy = null;
            commander = null;
            goingAfter = null;
            bstate = BS_WANDERING;
            navDest = null;
            blocked = 0;
            lastPos = other.pos;
        }	
    }
    
    void MoveToward(Actor other, double aimSpeed) {
        AimToward(other, aimSpeed);
        MoveForward();
        
        if (possessed.AngleTo(other) > possessed.Angle - 20)
            MoveRight();
            
        else if (possessed.Angle + 20 < possessed.AngleTo(other))
            MoveLeft();
            
        else
            MoveForward();
    }
    
    void MoveTowardPos(Vector3 other, double aimSpeed) {
        double ang = atan2(possessed.pos.y - other.y, possessed.pos.x - other.x);
    
        AimAtAngle(ang, aimSpeed);
        MoveForward();
        
        if (ang > possessed.Angle - 20)
            MoveRight();
            
        else if (possessed.Angle + 20 < ang)
            MoveLeft();
            
        else
            MoveForward();
    }
    
    void MoveRight() {
        possessed.MoveRight();
    }
    
    void MoveLeft() {
        possessed.MoveLeft();
    }
    
    void MoveAwayFrom(Actor other) {
        possessed.MoveForward();
        AimAwayFrom(other, 0.07);
    }
    
    void StepBackFrom(Actor other) {
        possessed.MoveBackward();
        AimToward(other, 0.085);
    }
    
    void StepBack() {
        possessed.StepBackward();
    }

    bool CheckObstructions() {
        FLineTraceData leftfront;
        FLineTraceData rightfront;
        FLineTraceData front;

        possessed.LineTrace(possessed.angle, 32, possessed.pitch, flags: TRF_THRUSPECIES | TRF_THRUHITSCAN, offsetz: 24, data: front);
        possessed.LineTrace(possessed.angle - 60, 120, possessed.pitch, flags: TRF_THRUSPECIES | TRF_THRUHITSCAN, offsetz: 24, data: leftfront);
        possessed.LineTrace(possessed.angle + 60, 120, possessed.pitch, flags: TRF_THRUSPECIES | TRF_THRUHITSCAN, offsetz: 24, data: rightfront);
        
        int flags = 0;
        
        if (leftfront.HitType != TRACE_HitNone)
            flags |= 0x1;
        
        if (rightfront.HitType != TRACE_HitNone)
            flags |= 0x2;

        if (front.HitType != TRACE_HitNone)
            flags |= 0x4;
        
        if (flags & 0x4) {
            if (flags & 0x3 == 0x3 || leftfront.Distance + rightfront.Distance < 80)
                possessed.MoveBackward();
                
            else if (flags & 0x1)
                possessed.angle += 5;
                
            else if (flags & 0x2)
                possessed.angle -= 5;
        }

        return flags & 0x4 != 0;
    }
    
    ActorList VisibleEnemies(Actor from) {
        ActorList res          = new("ActorList");
        ThinkerIterator iter   = ThinkerIterator.Create("Actor", STAT_DEFAULT);
        ThinkerIterator iter2  = ThinkerIterator.Create("Actor", STAT_PLAYER);
        Actor cur              = null;
        
        while (true) {
            if (!(cur = Actor(iter.Next())))
                if (!(cur = Actor(iter2.Next())))
                    break;

            if (cur == null || cur == from)                                                 continue;
            if (!(cur.bISMONSTER || cur.CheckClass("PlayerPawn", match_superclass: true)))  continue;
            if (cur.Health <= 0)                                                            continue;
            if (cur.bInvisible)                                                             continue;
            if (!(from.CheckSight(cur) && LineOfSight(cur, from)))                          continue;
            if (!IsEnemy(from, cur))                                                        continue;
            
            res.Push(cur);
        }
                
        return res;
    }
    
    ActorList VisibleFriends(Actor from) {
        ActorList res         = new("ActorList");
        ThinkerIterator iter  = ThinkerIterator.Create("Actor", STAT_DEFAULT);
        Actor cur             = null;

        while (cur = Actor(iter.Next())) {
            Vector2 off = possessed.Vec2To(cur);

            double pdot = 1;

            if (possessed.Distance2D(cur) > 0) {
                off.x /= possessed.Distance2D(cur);
                off.y /= possessed.Distance2D(cur);

                Vector2 avec = AngleToVector(possessed.angle);

                double pdot = off.x * avec.x + off.y * avec.y;
            }

            if (cur != null && cur != from && cur.Health > 0 && from.CheckSight(cur) && (( cur.bISMONSTER && !isEnemy(from, cur)) || (cur.CheckClass("PlayerPawn", AAPTR_DEFAULT, true) == from.bFRIENDLY)) && pdot > 0.3)
                res.Push(cur);
        }
                
        return res;
    }

    uint debugCount;
    
    bool MoveTowardDest() {
        Actor dest = navDest;
        
        if (!dest)
            dest = goingAfter;
            
        if (!dest)
            dest = enemy;
            
        if (!dest)
            return false;
    
        // MakeDestBall(dest);
        MoveToward(dest, 0.2);
        return true;
    }

    void MakeDestBall(Actor Other) {
        if (CVar.FindCVar("zb_debug").GetInt() > 0 && debugCount < 1) {
            debugCount = 20;
            DestBall db = DestBall(possessed.SpawnMissile(Other, "DestBall"));

            if (db != null)
                db.targetNode = Other;
        }
    }
    
    void SmartMove(ZTPathNode toward = null) {
        if (toward == null) toward = navDest;
        if (toward == null) return;

        if (!possessed.CheckSight(toward)) toward = currNode;

        if (possessed != null) {
            if (currNode != null && currNode.nodeType == ZTPathNode.NT_USE)
                DodgeAndUse();

            if (toward != null) {
                if (currNode != null) {
                    if (toward.nodeType == ZTPathNode.NT_JUMP) {
                        aimToward(toward, 0.1, 0.1);
                    
                        if (possessed.pos.z - possessed.floorz < 1)
                            possessed.Jump();
                    }
                    
                    else if (toward.nodeType == toward.NT_CROUCH)
                        possessed.moveType = ZetaBotPawn.MM_Crouch;
                        
                    else if (toward.nodeType == toward.NT_SLOW)
                        possessed.moveType = ZetaBotPawn.MM_None;
                        
                    else
                        possessed.moveType = ZetaBotPawn.MM_Run;
                        
                    if (toward.pos.z - possessed.pos.z > 28 && possessed.pos.z - possessed.floorz < 1)
                        possessed.Jump();
                        
                    if (currNode.nodeType == ZTPathNode.NT_USE)
                        DodgeAndUse();

                    else if (currNode.nodeType == ZTPathNode.NT_SHOOT && enemy == null) {
                        if (FRandom(0, 1) < 0.7 && FireBestWeapon())
                            possessed.BeginShoot();

                        else
                            possessed.EndShoot();
                    }
                         
                    MoveToward(toward, 20);
                }
                    
                else
                    MoveToward(toward, 20);
            }
            
            else
                angleMomentum += FRandom(-0.01, 0.01);
                
                if (FRandom(0, 99.9) < 10)
                    RandomStrafe();
                
                else
                    MoveForward();
        }
    }
    
    void MoveForward() {
        possessed.MoveForward();
    }
    
    static const String BStateNames[] = {
        "wandering",
        "hunting",
        "attacking",
        "following",
        "fleeing"
    };
    
    void SetBotState(uint s) {
        //if (currentOrder != null) 
        //    SetOrder(null);

        if (s != bstate)
            DebugLog(LT_INFO, myName.." is now \ck"..BStateNames[s].."!");
            
        bstate = s;
    }

    void ConsiderSetBotState(uint s) {
        if (s == BS_WANDERING && currentOrder != null && currentOrder.orderType == BS_FOLLOWING)
            currentOrder.Apply(self);

        else
            SetBotState(s);
    }

    ZTBotOrder currentOrder;

    void SetOrder(ZTBotOrder newOrder) {
        if (newOrder != currentOrder) {
            if (newOrder != null) {
                DebugLog(LT_INFO, myName.." was set to \ck"..newOrder.v_imperative.."!");
            }

            else {
                DebugLog(LT_INFO, myName.." has no orders now ("..(currentOrder.v_past)..").");
            }
        }

        currentOrder = newOrder;
    }
    
    void SetCurrentNode(ZTPathNode pn) {
        if (pn == null)
            return;

        if (pn != currNode)
            DebugLog(LT_VERBOSE, String.Format("%s is now at the %s node: \ck%s", myName, ZTPathNode.ZTNavTypeNames[pn.nodeType], pn.NodeName()));
         
        pastNode = currNode;
        currNode = pn;
    }
    
    bool isEnemy(Actor from, Actor other) {
        return from.bFRIENDLY != other.bFRIENDLY || (!from.bFRIENDLY && other.CheckClass("PlayerPawn", AAPTR_DEFAULT, true)) || CVar.FindCVar('deathmatch').GetInt() > 0;
    }
    
    ZTPathNode ClosestNode(Actor other) {
        ThinkerIterator iter = ThinkerIterator.Create("ZTPathNode", 91);
        ZTPathNode best = null;
        ZTPathNode cur = null;
        
        while (cur = ZTPathNode(iter.Next()))
            if (best == null || other.Distance3D(cur) < other.Distance3D(best))
                best = cur;
                
        return best;
    }
    
    bool LineOfSight(Actor other, Actor from = null) {
        if (other == null)
            return false;

        if (from == null) from = possessed;
        if (from == null) return false;

        if (other.Distance2D(from) > 80) {
            let off = from.Vec2To(other) / from.Distance2D(other);
            let dir = AngleToVector(from.angle);
            double ddot = (off.x * dir.x) + (off.y * dir.y);

            if (ddot <= 0) return false;
        }

        if (!from.CheckSight(other) && LineTrace(from.AngleTo(other), from.Distance3D(other), PitchTo(other), flags: TRF_THRUACTORS | TRF_THRUHITSCAN, offsetz: from.height / 2)) return false;

        return true;
    }

    double PitchTo(Actor other, Actor from = null) {
        if (other == null)
            return 0;

        if (from == null) from = possessed;
        if (from == null) return 0;

        if (other.pos.z + other.height / 2 == from.pos.z + from.height / 2) return 0;

        //return other.pos.z + other.height / 2 - from.pos.z - from.height / 2;
        return tan(other.pos.z + other.height / 2 - from.pos.z - from.height / 2);
    }
    
    ZTPathNode ClosestVisibleNode(Actor other) {
        ThinkerIterator iter = ThinkerIterator.Create("ZTPathNode", 91);
        ZTPathNode best = null;
        ZTPathNode cur = null;
        
        while (cur = ZTPathNode(iter.Next())) {
            if (!other.CheckSight(cur))
                continue;

            if (best == null || other.Distance3D(cur) < other.Distance3D(best))
                best = cur;
        }
                
        return best;
    }
    
    void RandomStrafe() {
        strafeMomentum += FRandom(-0.1, 0.1);
        
        if (strafeMomentum < -1) 
            strafeMomentum = -1;
            
        if (strafeMomentum > 1) 
            strafeMomentum = 1;
            
        if (strafeMomentum > 0)
            possessed.MoveRight();
            
        else
            possessed.MoveLeft();
    }
    
    BotState assessBotAttitude(Actor other) { // mimicks UT99's TournamentGameInfo(?).AssessBotAttitude(Pawn Other)
        if (isEnemy(possessed, other))
            return BS_ATTACKING;
            
        else
            return BS_WANDERING;
    }
    
    ZetaWeapon, bool, double BestWeaponAllTic() {
        double bestRate = 0;
        bool bAltFire = false;
        ZetaWeapon zweap = null;
        ZetaWeapon bestWeap = null;
        Weapon weap = null;
        let iter = ThinkerIterator.create("Weapon", STAT_INVENTORY);
        
        while (weap = Weapon(iter.Next()))
            if (weap.Owner == possessed) {
                ZetaWeapon zweap = loader.CheckType(weap);
                // A_Log(myName.." > "..weap.GetClassName());
            
                if (zweap != null) {
                    let assessed1 = zweap.GetRating(self, enemy);
                    let assessed2 = zweap.GetAltRating(self, enemy);
                    let alt = zweap.CanAltFire(possessed) && (assessed2 > assessed1 || !zweap.CanFire(possessed) );
                    
                    if (!(alt || zweap.CanFire(possessed)))
                        continue;
                        
                    if (CVar.FindCVar("zb_debug").GetInt() > 2)
                        DebugLog(LT_VERBOSE, myName.." considering a "..zweap.GetClassName()..": alt="..alt.." rating="..(alt ? assessed2 : assessed1).."dm");
                    
                    let maxAssessed = alt ? assessed2 : assessed1;
                
                    // A_Log("("..zweap.GetClassName().." -> "..maxAssessed..")");
                
                    if (bestWeap == null || maxAssessed > bestRate) {
                        bestRate = maxAssessed;
                        bestWeap = zweap;
                        bAltFire = alt;
                    }
                }
            }
        
        return bestWeap, bAltFire, bestRate;
    }

    bool FireBestWeapon() {
        // if (absangle(possessed.angle, possessed.AngleTo(enemy)) > 80)
        //     return false;
    
        // if (lastWeap != null && BestWeaponAllTic() == lastWeap)
        /* {
            if (lastWeap.CanAltFire(possessed) && lastWeap.GetAltRating(self, enemy) > lastWeap.GetRating(self, enemy)) {
                if (age - lastShot > 0) {
                    DebugLog(LT_VERBOSE, myName.." alt-fired a "..lastWeap.GetClassName().."!");
                    lastWeap.AltFire(possessed, enemy);
                    
                    if (lastWeap.altammouse > 0)
                        possessed.A_TakeInventory(lastWeap.altammotype, lastWeap.altammouse);

                    lastShot = age + lastWeap.IntervalSeconds();
                    DebugLog(LT_VERBOSE, myName.." can shoot again after "..lastWeap.IntervalSeconds().." seconds, or alt-fire after "..lastWeap.AltIntervalSeconds().." seconds!");
                    
                    return true;
                }
                    
                return false;
            }
            
            else if (lastWeap.CanFire(possessed)) {
                if (age - lastShot > 0) {
                    DebugLog(LT_VERBOSE, myName.." fired a "..lastWeap.GetClassName().."!");
                    lastWeap.Fire(possessed, enemy);

                    if (lastWeap.ammouse > 0)
                        possessed.A_TakeInventory(lastWeap.ammotype, lastWeap.ammouse);

                    lastShot = age + lastWeap.IntervalSeconds();
                    DebugLog(LT_VERBOSE, myName.." can shoot again after "..lastWeap.IntervalSeconds().." seconds, or alt-fire after "..lastWeap.AltIntervalSeconds().." seconds!");

                    return true;
                }
                    
                return false;
            }
        }
        */
    
        if (age < lastShot)
            return false;

        ZetaWeapon bestWeap;
        bool bAltFire;

        [ bestWeap, bAltFire ] = BestWeaponAllTic();
        
        if (bestWeap == null)
            return false;
        
        if (bAltFire && bestWeap.CanAltFire(possessed, true)) {
            lastShot = age + bestWeap.AltIntervalSeconds();
            bestWeap.AltFire(possessed, enemy);
        }
            
        else if (bestWeap.CanFire(possessed, true)) {
            lastShot = age + bestWeap.IntervalSeconds();
            bestWeap.Fire(possessed, enemy);
        }
            
        else
            return false;

        DebugLog(LT_VERBOSE, myName.." "..(bAltFire ? "alt-" : "").."fired a "..bestWeap.GetClassName().."!");
        DebugLog(LT_VERBOSE, myName.." can only shoot again in "..lastShot - age.." seconds!");
            
        numShoots++;
        lastWeap = bestWeap;
            
        return true;
    }
    
    void RandomMove() { // nodeless wandering
        if (FRandom(0, 1) < 0.3) {
            angleMomentum += FRandom(-0.03, 0.03);

            if (FRandom(0, 1) < 0.125)
                angleMomentum *= -0.2;
        }

        else angleMomentum /= 1.1;
                            
        if (FRandom(0, 1) < 0.7)
            MoveForward();
        
        else if (FRandom(0, 1) < 0.5)
            RandomStrafe();
            
        else
            StepBack();
    }
    
    /* -- unused
    virtual WeaponRating rateWeapon(Weapon weap) {
        WeaponRating res = new("WeaponRating");
        
        if (enemy == null) {
            res.rating = 0;
            res.bAlt = false;
            return res;
        }
    
        double rprimary = 0;
        double raltern  = 0;
        double rboth    = 0;
    
        if (possessed.Distance3D(enemy) < target.radius + radius + 256)
            rboth += weap.Kickback * 4;
            
        if (weap.ProjectileType != null) {
            let proj = Spawn(weap.ProjectileType);
            rprimary += proj.speed * possessed.Distance3D(enemy) + proj.damage;
            proj.Destroy();
        }
        
        else {
            double rangeRate = 1024;
            rangeRate -= possessed.Distance3D(enemy) / 2;
            
            if (rangeRate > 0)
                rprimary += rangeRate;
        }
        
        if (weap.AltProjectileType != null) {
            let proj = Spawn(weap.AltProjectileType);
            raltern += proj.speed * possessed.Distance3D(enemy) + proj.damage;
            proj.Destroy();
        }
        
        else {
            double rangeRate = 1024;
            rangeRate -= possessed.Distance3D(enemy) / 2;
            
            if (rangeRate > 0)
                raltern += rangeRate;
        }
        
        Inventory ammo1 = FindInventory(weap.AmmoType1);
        Inventory ammo2 = FindInventory(weap.AmmoType2);
        
        if (ammo1 != null)
            rboth += ammo1.Amount * 2;
            
        if (ammo2 != null)
            rboth += ammo2.Amount * 2;
        
        if (raltern > rprimary) {
            res.rating = raltern + rboth;
            res.bAlt = true;
        }
        
        else {
            res.rating = rprimary + rboth;
            res.bAlt = false;
        }
        
        return res;
    }
    */
    
    bool BotChat(String kind, double importance) {
        if (kind == "IDLE" && CVar.FindCVar("zb_noidletalk").GetBool())
            return false;

        if (FRandom(0, 1.0) >= importance * CVar.FindCVar("zb_talkfrequency").GetFloat() / 3)
            return false;
    
        possessed.A_PlaySound("zetabot/"..myVoice.."/"..kind, CHAN_VOICE, attenuation: 0.7);
        possessed.A_PlaySound("misc/chat", CHAN_UI, 0.2, false, ATTN_NONE);

        DebugLog(LT_VERBOSE, myName.." called a "..kind.." voice");

        return true;
    }
    
    double targetPriority(Actor other) {
        // The smalest the number, the highest the priority :)
        double res = possessed.Distance3D(other) / other.Health;

        if (other.CheckClass('PlayerPawn'))
            res /= 1.5;

        return res;
    }
    
    void LogStats() {
        if (possessed == null)
            return;
            
        String enemyType = "none";
        String goingAfterType = "none";
        String currNodeS = "none";
        String navDestS = "none";
        
        if (enemy != null)
            enemyType = enemy.GetClassName();
            
        if (goingAfter != null)
            goingAfterType = goingAfter.GetClassName();
        
        if (currNode != null)
            currNodeS = currNode.NodeName();
            
        if (navDest != null)
            navDestS = navDest.NodeName();
    
        String lastWeapS = "none.";
        bool useNode = (currNode != null && currNode.nodeType == ZTPathNode.NT_USE );
        
        if (lastWeap != null)
            lastWeapS = lastWeap.GetClassName();
    
        if (enemy == null)
            DebugLog(LT_VERBOSE, "["..myName.."'s STATS] Health: "..possessed.health.." | Current State: "..BStateNames[bstate].." | Enemy Type: None | Going After Type: "..goingAfterType.." | Current Pathnode: "..currNodeS..(useNode ? " (use)" : "").." | Destination Pathnode: "..navDestS.." | Age: "..age.."s | Best Weapon: none. | Last Weapon: "..lastWeapS);
            
        else {
            ZetaWeapon wp;
            double rt;
            bool _;
            String enemyH = " | Enemy Health: "..enemy.Health;
        
            [ wp, _, rt ] = BestWeaponAllTic();
            DebugLog(LT_VERBOSE,
                "["..myName.."'s STATS] Health: "..possessed.health.." | Current State: "..BStateNames[bstate].." | Enemy Type: "..enemyType..enemyH.." | Going After Type: "..goingAfterType.." | Current Pathnode: "..currNodeS..(useNode ? " (use)" : "").." | Destination Pathnode: "..navDestS.." | Age: "..age.."s "..
                    (wp == null ? "" : ("| Best Weapon: "..wp.GetClassName().." ("..rt.." dopamine molecules"..(_ ? ", alt" : "")..") ")
              ) .."| Last Weapon: "..lastWeapS
            );
        }
    }
    
    // bot death listener
    void OnDeath() {
        A_PrintBold("\cg"..myName.." has just died!");
        
        let friends = VisibleFriends(possessed);
        Object a = null;
        ZetaBotPawn zb = null;
        
        /*
        while (a = friends.iNext())
            if ((zb = ZetaBotPawn(a)) && possessed.Distance3D(zb) < 2048 / friends.Length() && zb.cont.bState == BS_ATTACKING && zb.cont != null)
                zb.cont.ConsiderSetBotState(BS_FLEEING);
        */
                
        NumBots.Get().value--;
    }

    void Subroutine_Follow() {
        if (possessed.Distance3D(goingAfter) < 400 || possessed.CheckSight(goingAfter))
            ConsiderSetBotState(BS_WANDERING);

        else {
            BotChat("IDLE", 2.25 / 90);

            if (DodgeAndUse())
                ConsiderSetBotState(BS_WANDERING);
        
            if (goingAfter != null) {
                if (possessed.Distance3D(goingAfter) < 1024 && possessed.CheckSight(goingAfter))
                    ConsiderSetBotState(AssessBotAttitude(goingAfter));
            
                else if (currNode != null && (navDest == null || Distance3D(navDest) < 512 || navDest == currNode)) {
                    if (ClosestNode(goingAfter) == currNode) {
                        ConsiderSetBotState(BS_WANDERING);
                    }
                        
                    else if (pathCountdown <= 0) {
                        ActorList path = navDest.findPathTo(ClosestNode(goingAfter), possessed);
                        
                        if (path != null && path.Length() > 1) {
                            navDest = ZTPathNode(path.get(0));
                            
                            DebugLog(LT_INFO, "Next navigation point found: "..navDest.NodeName());
                            SmartMove(navDest);
                        }
                            
                        else
                            MoveToward(goingAfter, 0.27);

                        pathCountdown += 24;
                    }

                    else
                        pathCountdown--;
                }
                
                else if (navDest != null)
                    SmartMove();
                
                else if (possessed.Distance3D(goingAfter) < 256)
                    ConsiderSetBotState(BS_ATTACKING);
                        
                else if (possessed.Distance3D(goingAfter) > 1500 && !possessed.CheckSight(goingAfter))
                    ConsiderSetBotState(BS_WANDERING);
                    
                else
                    MoveToward(goingAfter, 15);
            }
            
            else
                ConsiderSetBotState(BS_WANDERING);
        }
    }

    void Subroutine_Hunt() {
        if (enemy == null || enemy.Health <= 0) {
            enemy = null;
            ConsiderSetBotState(BS_WANDERING);
            SetOrder(null);

            if (lastEnemyPos != null) lastEnemyPos.Destroy();
            lastEnemyPos = null;
        }
    
        else if (LineOfSight(enemy) || possessed.Distance3D(enemy) < 96) {
            AimToward(enemy, 15);
            ConsiderSetBotState(BS_ATTACKING);
            possessed.Jump();

            if (lastEnemyPos != null) lastEnemyPos.Destroy();
            lastEnemyPos = null;
        }
    
        else {
            RefreshEnemy();

            if (bstate == BS_HUNTING) {
                if (lastEnemyPos == null) {
                    ConsiderSetBotState(BS_WANDERING);
                    return;
                }

                double lastPosSqDist = ((possessed.pos.x - lastEnemyPos.pos.x) * (possessed.pos.x - lastEnemyPos.pos.x))
                                        + ((possessed.pos.y - lastEnemyPos.pos.y) * (possessed.pos.y - lastEnemyPos.pos.y));

                if (lastPosSqDist < 40 * 40) {
                    enemy = null;
                    ConsiderSetBotState(BS_WANDERING);

                    if (lastEnemyPos != null) lastEnemyPos.Destroy();
                    lastEnemyPos = null;
                }
                    
                else if (lastEnemyPos != null) {
                    if (possessed.CheckSight(lastEnemyPos))
                        SmartMove(lastEnemyPos);

                    else if (currNode != null && (navDest == null || possessed.Distance2D(navDest) < 64)) { // path to lastEnemyPos
                        ActorList path = currNode.findPathTo(lastEnemyPos, possessed);
                        
                        if (path != null && path.Length() > 0) {
                            for (uint iii = 0; iii < path.Length(); iii++) {
                                if (path.get(iii) == null)
                                    DebugLog(LT_VERBOSE, String.Format("Null node in path: %i", iii));
                            }

                            navDest = ZTPathNode(path.get(0));

                            if (navDest == null) {
                                ConsiderSetBotState(BS_WANDERING);
                                return;
                            }

                            else {
                                SmartMove(navDest);
                                
                                DebugLog(LT_INFO, "Next navigation point found: "..navDest.NodeName());
                            }
                        }

                        if (navDest == null)
                            ConsiderSetBotState(BS_WANDERING);
                    }

                    else if (navDest != null)
                        SmartMove(navDest);
                
                    else
                        ConsiderSetBotState(BS_WANDERING);

                    if (bstate == BS_HUNTING) {
                        if (FRandom(0, 1) < 0.12)
                            possessed.Jump();

                        AutoUseAtAngle(0);
                    }
                }

                else {
                    enemy = null;
                    ConsiderSetBotState(BS_WANDERING);
                }

                if (bstate == BS_HUNTING) {
                    BotChat("ACTV", 0.025);
                }
            }
        }

        return;
    }
    
    bool DodgeAndUse() {
        if (currNode == null)
            return false;
    
        if (currNode.nodeType == ZTPathNode.NT_USE) {
            FLineTraceData useData;
            MoveTowardPos(currNode.pos + currNode.Vec3Angle(64 + possessed.radius, currNode.useDirection, 0, false), 0.45);
            AimAtAngle(currNode.useDirection, 35);
            
            possessed.LineTrace(
                possessed.angle,
                possessed.radius + 64,
                0, // possessed.pitch,
                flags: TRF_THRUBLOCK | TRF_THRUHITSCAN | TRF_THRUACTORS,
                offsetz: possessed.height - 24, // offsetz: possessed.height - 12,
                data: useData
            );
            
            if (useData.HitType == TRACE_HitWall) {
                if (useData.HitLine.Special > 0) {
                    Line l = useData.HitLine;
                    DebugLog(LT_VERBOSE, "["..myName.." USE NODE LOGS] Activating wall! Line special: "..l.Special);
                    l.Activate(possessed, 0, SPAC_Use);

                    Level.ExecuteSpecial(
                        l.Special,
                        possessed,
                        l, 0,

                        l.Args[0],
                        l.Args[1],
                        l.Args[2],
                        l.Args[3],
                        l.Args[4]
                    );
                }

                else {
                    if (GruntInterval == 0 || GruntInterval-- == 0) {
                        possessed.A_PlaySound("ztmisc/grunt", CHAN_VOICE, attenuation: 1.1);
                        GruntInterval = 20;
                        Log(GruntInterval);
                    }

                    MoveAwayFrom(currNode);
                    MoveAwayFrom(currNode);

                    return false;
                }
            }
        }

        else if (currNode.nodeType == ZTPathNode.NT_JUMP && FRandom(0, 1) < 0.8) {
            possessed.Jump();
            AimAtAngle(currNode.Angle, 70, 20);
        }
        
        if (FRandom(0, 1) < 0.0175)
            possessed.Jump();

        CheckObstructions();
            
        return currNode.nodeType == ZTPathNode.NT_USE;
    }

    void RefreshEnemy() {
        if (currentOrder != null && currentOrder.lookedAt != null && LineOfSight(currentOrder.lookedAt) && (
            currentOrder.orderType == BS_ATTACKING ||
            currentOrder.orderType == BS_FLEEING   ||
            currentOrder.orderType == BS_FOLLOWING
        )) {
            currentOrder.Apply(self);
            return;
        }

        ActorList mon = VisibleEnemies(possessed);
    
        if (mon.length() > 0) {
            PriorityQueue targets = new("PriorityQueue");
        
            for (uint i = 0; i < mon.length(); i++)
                targets.add(mon.get(i), TargetPriority(mon.get(i)));
        
            Actor newEnemy = Actor(targets.poll());

            if (enemy == null || TargetPriority(enemy) < TargetPriority(newEnemy))
                enemy = Actor(newEnemy);

            /*
            else {
                if (retargetCount < 1) {
                    enemy = Actor(targets.poll());
                    retargetCount = 15;
                }

                else
                    retargetCount--;
            }
            */

            DebugLog(LT_INFO, "Attacking a "..enemy.GetClassName());
            
            BotChat("TARG", 0.8);
            
            ConsiderSetBotState(BS_ATTACKING);
        }
    }

    void Subroutine_Flee() {
        if (DodgeAndUse()) {
            if (currNode != null)
                navDest = currNode.RandomNeighbor();

            else
                navDest = null;

            ConsiderSetBotState(BS_WANDERING);
        }
    
        if (enemy != null && possessed.Distance3D(enemy) < 1024 && possessed.CheckSight(enemy) && possessed.Health < possessed.default.Health / 7)
            MoveAwayFrom(enemy);
        
        else
            ConsiderSetBotState(BS_WANDERING);
    }

    void Subroutine_Attack() {
        if (enemy != null && enemy.Health >= 1) { // health is integer
            if (bstate != BS_HUNTING && !LineOfSight(enemy)) {
                possessed.EndShoot();

                if (lastEnemyPos != null) lastEnemyPos.Destroy();
                lastEnemyPos = ZTPathNode.plopNode(enemy.pos, ZTPathNode.NT_TARGET);
                
                navDest = null;
                ConsiderSetBotState(BS_HUNTING);
            }
            
            else {
                if (FRandom(0, 1) < 0.06)
                    possessed.Jump();
            
                BotChat("ACTV", 0.05);

                ZetaWeapon w = BestWeaponAllTic();

                if (w == null) {
                    enemy = null;
                    goingAfter = null;
                    
                    possessed.EndShoot();
                    ConsiderSetBotState(BS_WANDERING);
                }

                else {
                    if (possessed.Distance3D(enemy) > 256 + enemy.radius || w.IsMelee())
                        MoveToward(enemy, 0.282);
                        
                    else if (possessed.Distance3D(enemy) < 128 + enemy.radius)
                        StepBackFrom(enemy);

                    RandomStrafe();
                    AimToward(enemy, 0.27, 30);

                    if (!LineOfSight(enemy))
                        possessed.EndShoot();

                    else {
                        let off = possessed.Vec2To(enemy) / possessed.Distance2D(enemy);
                        let dir = AngleToVector(possessed.angle);
                        double ddot = (off.x * dir.x) + (off.y * dir.y);

                        if (dDot <= 0)
                            possessed.EndShoot();

                        else if (FireBestWeapon())
                            possessed.BeginShoot();
                            
                        else
                            possessed.EndShoot();
                    }
                }
            }
        }

        else {
            SetOrder(null);
            BotChat("ELIM", 0.75);

            StepBackFrom(enemy);

            possessed.EndShoot();
            ConsiderSetBotState(BS_WANDERING);
        }
    }

    void GiveCommands() {
        ZTBotOrder myOrder = ZTBotOrder.Make(possessed, bstate == BS_FOLLOWING ? goingAfter : enemy, bstate == BS_ATTACKING ? BS_HUNTING : bstate);

        ActorList friends = VisibleFriends(possessed);
        ZetaBotPawn friend;

        friends.iReset();

        bool chat = false;
        uint i = 0;
            
        while (i < friends.Length()) {
            friend = ZetaBotPawn(friends.Get(i++));

            if (friend && friend.cont && friend.cont.commander == self) {
                myOrder.Apply(friend.cont);

                if (!chat) {
                    BotChat("ORDR", 0.2);
                    chat = true;
                }
            }
        }
    }

    void Subroutine_Wander() {
        enemy = null;
        BotChat("IDLE", 2.25 / 100);
            
        MoveForward();
        
        /*
        if (commander != null && (possessed.Distance3D(commander) > 400 && !possessed.CheckSight(commander)) && ClosestNode(commander) != currNode) {
            ConsiderSetBotState(BS_WANDERING);
            DodgeAndUse();
        
            ConsiderSetBotState(BS_FOLLOWING);
            goingAfter = commander;
        }
    
        else
        */
        
        if (commander == null) { // get a commander
            ActorList friends = VisibleFriends(possessed);
            
            if (friends.length() > 0) {
                commander = friends.get(Random(0, friends.length() - 1));
                
                if (ZetaBotPawn(commander)) {
                    let ztcom = ZetaBotPawn(commander);
                    
                    if (ztcom == null || ztcom.cont == null)
                        DebugLog(LT_INFO, myName.." is now led by a "..commander.GetClassName());
                        
                    else
                        DebugLog(LT_INFO, myName.." is now led by "..ztcom.cont.myName);
                }
                
                BotChat("COMM", 0.8);
            }
        }
    
        if (commander == null && bstate != BS_HUNTING) { // wander around
            if (currNode == null)
                SetCurrentNode(ClosestVisibleNode(possessed));
                
            DodgeAndUse();

            if (currNode != null)
                navDest = currNode.RandomNeighbor();

            else
                navDest = null;
        
            if (currNode != null && possessed.Distance2D(currNode) < 100 && navDest != null) {
                MoveToward(navDest, 10); // wander to this random 'neighboring' node
            }
            
            else RandomMove();
        }
    }

    void FireAtBarrels() {
        let it_barrels = ThinkerIterator.create("ExplosiveBarrel", STAT_DEFAULT);
        ExplosiveBarrel bclosest = null, bar = null;
        double bdist = 100;

        while (bar = ExplosiveBarrel(it_barrels.Next())) {
            if (!LineOfSight(bar)) continue;
            if (possessed.Distance2D(bar) < bdist) {
                bclosest = bar;
                bdist = possessed.Distance2D(bar);

                DebugLog(LT_VERBOSE, String.Format("Considering shootable barrel %fpx away.", bdist));
            }
        }

        if (bclosest != null) {
            AimToward(bclosest, 15);

            if (possessed.Distance2D(currNode) > 100 && CVar.FindCVar('zb_autonodes').GetBool()) {
                SetCurrentNode(ZTPathNode.plopNode(possessed.pos, ZTPathNode.NT_SHOOT, possessed.AngleTo(bclosest)));

                if (currNode != null)
                    DebugLog(LT_INFO, String.Format("Defining shootable barrel %fpx away: %s", bdist, currNode.NodeName()));
            }

            else { 
                if (AbsAngle(possessed.AngleTo(bclosest), possessed.angle) <= 100) {
                    if (FireBestWeapon()) possessed.BeginShoot();
                }

                else
                    possessed.EndShoot();
            }
        }
    }
    
    void A_ZetaTick() {
        if (TelefragTimer > 0) TelefragTimer--;

        if (possessed == null || possessed.Health <= 0) {
            if (lastEnemyPos != null) lastEnemyPos.Destroy();

            if (CVar.FindCVar('zb_respawn').GetBool() && (CVar.FindCVar('deathmatch').GetInt() > 0 || CVar.FindCVar('zb_cooprespawn').GetBool())) {
                DebugLog(LT_VERBOSE, String.format("Setting Respawn mode for %s.", myName));
                SetStateLabel("Respawn");
            }

            else
                Destroy();

            return;
        }

        possessed.ApplyMovement();

        if (currNode != null && currNode.nodeType == ZTPathNode.NT_AVOID)
            MoveAwayFrom(currNode);
    
        possessed.angle += angleMomentum;
        angleMomentum *= 0.92;
        
        if (possessed.health <= 0)
            return;
            
        age += 1. / 35;
        debugCount -= 1;
            
        if (age - lastShot > 0.7 && possessed.bShooting)
            possessed.EndShoot();
            
        SetCurrentNode(ClosestVisibleNode(possessed));
        
        if (enemy != null && enemy.Health <= 0) {
            if (lastEnemyPos != null) lastEnemyPos.Destroy();
            enemy = null;

            if (bstate == BS_ATTACKING) {
                bstate = BS_WANDERING;
                
                enemy = null;
                goingAfter = null;

                possessed.EndShoot();
                ConsiderSetBotState(BS_WANDERING);
            }
        }

        if (--logRate <= 0) {
            logRate = 50;
            LogStats();
        }
        
        if (possessed.blockingMobj != null || possessed.blockingLine != null)
            blocked += 1 + sqrt(possessed.vel.x * possessed.vel.x + possessed.vel.y * possessed.vel.y) / 2;
            
        if (blocked > 0) {
            blocked--;
            RandomStrafe();
            possessed.MoveBackward();
            possessed.angle += 3;
        }
        
        let pickupIter = ThinkerIterator.Create("Weapon", STAT_INVENTORY);
        Weapon inv;
        
        while ((inv = Weapon(pickupIter.Next())) != null) {
            if (inv.owner != null) continue;

            if (possessed.Distance2D(inv) < possessed.Radius + inv.Radius) if (abs(possessed.pos.z - inv.pos.z) < possessed.Height + inv.Height) {
                ZetaWeapon zw = loader.CheckType(inv);
            
                if (zw != null )	
                    inv.CallTryPickup(possessed); // weapon items are checked by fireBestWeap
            }
        }

        if (currNode != null && currNode.nodeType == ZTPathNode.NT_USE)
            DodgeAndUse();

        else if (CVar.FindCVar('zb_autouse').GetBool())
            AutoUseAtAngle(0);
            
        GiveCommands();

        if (bstate != BS_ATTACKING) {
            if (bstate == BS_HUNTING)
                Subroutine_Hunt();

            if (bstate != BS_FLEEING)
                RefreshEnemy();
        
            if (navDest != null) {
                if (bstate == BS_WANDERING || bstate == BS_FOLLOWING)
                    BotChat("IDLE", 2.25 / 85); // talk

                if (currNode != null && possessed.Distance2D(currNode) > 160 && possessed.Distance2D(navDest) > navDest.Distance2D(currNode) && bstate != BS_WANDERING)
                    SmartMove(currNode); // move to current node if too far

                else if (possessed.Distance3D(navDest) > 100) {
                    if (bstate != BS_WANDERING || possessed.Distance3D(navDest) < 350)
                        SmartMove(navDest); // move to destination node if not close enough

                    else
                        navDest = null;
                }
                    
                else {
                    if (bstate == BS_FOLLOWING || currNode == navDest)
                        navDest = null; // reset destination node

                    else
                        RandomMove();

                    SetOrder(null);
                }
            }
            
            else {
                if (currNode != null) {
                    if (bstate != BS_WANDERING) navDest = currNode.RandomNeighbor();

                    if (navDest == null || bstate == BS_WANDERING) RandomMove();
                }
            
                if (bstate == BS_FOLLOWING)
                    Subroutine_Follow();
                
                else if (bstate == BS_FLEEING)
                    Subroutine_Flee();
                
                else if (bstate == BS_WANDERING)
                    Subroutine_Wander();
            }
        }
            
        else Subroutine_Attack();
        
        if ((currNode == null || possessed.Distance2D(currNode) > 300) && CVar.FindCVar('zb_autonodes').GetBool()) {
            SetCurrentNode(ZTPathNode.plopNode(possessed.pos, ZTPathNode.NT_NORMAL, possessed.angle));
        }	

        else if (currNode != null)
            FireAtBarrels();

        if (angleMomentum > 1)
            angleMomentum = 1;
            
        if (angleMomentum < -1)
            angleMomentum = -1;
    }

    States {
        Spawn:
            TNT1 A 1;
            Goto TickLoop;

        Respawn:
            TNT1 A 12;
            TNT1 A 0 A_Jump(180, "Respawn");
            TNT1 A 1 A_ZetaRespawn;
            TNT1 A 0 A_JumpIf(possessed.Health <= 0, "Respawn");
            Goto TickLoop;
            
        TickLoop:
            TNT1 A 1 A_ZetaTick;
            Loop;
    }
}

class ZetaBot : Actor {
    enum LogType {
        LT_ERROR = 0,
        LT_WARNING,
        LT_INFO,
        LT_VERBOSE
    };

    void DebugLog(LogType kind, String msg) {
        if (CVar.FindCVar("zb_debug").GetInt() > 0) {
            String logHeader = "";
        
            if (kind == LT_ERROR)
                logHeader = "\cr[ERROR]";
                
            else if (kind == LT_WARNING)
                logHeader = "\cf[WARNING]";
                
            else if (kind == LT_INFO)
                logHeader = "\ch[INFO]";
                
            else if (kind == LT_VERBOSE) {
                if (CVar.FindCVar("zb_debug").GetInt() > 1)
                    logHeader =	"\cd[VERBOSE]";
                
                else
                    return;
            }
        
            A_Log("\cq[ZetaBot] "..logHeader.." "..msg);
        }
    }

    override void PostBeginPlay() {
        Super.PostBeginPlay();

        bool bHasNode;
        let ni = ThinkerIterator.create("ZTPathNode", 91);
        
        if (ni.Next())
            bHasNode = true;
            
        if (!bHasNode && CVar.FindCVar("nodelist").GetString() != "::NONE")
            ZTPathNode.plopNodes(CVar.FindCVar("nodelist").GetString());
            
        DebugLog(LT_VERBOSE, "Serialized Nodes: "..ZTPathNode.serializeLevel());
    
        ZTBotController cont = ZTBotController(Spawn("ZTBotController", pos));
        
        if (cont == null)
            return;
        
        cont.possessed.angle = angle;

        if (zb_autonoderespawn) {
            let iter = ThinkerIterator.Create("ZTPathNode", 91);
            bool can = true;
            ZTPathNode pn;

            while (pn = ZTPathNode(iter.Next()))
                if (pn.nodeType == ZTPathNode.NT_RESPAWN && pn.Distance2D(cont.possessed) < 64) {
                    can = false;
                    break;
                }

            if (can) {
                DebugLog(LT_INFO, String.format("Added respawn node at location x=%f,y=%f,z=%f", pos.x, pos.y, pos.z));
                ZTPathNode.plopNode(cont.possessed.pos, ZTPathNode.NT_RESPAWN, angle);
            }
        }
        
        DebugLog(LT_INFO, "ZetaBot spawned with success! Class: "..cont.possessed.GetClassName());
        Destroy();
    }
}

class ZetaSpirit : Actor {
    enum LogType {
        LT_ERROR = 0,
        LT_WARNING,
        LT_INFO,
        LT_VERBOSE
    };

    void DebugLog(LogType kind, String msg) {
        if (CVar.FindCVar("zb_debug").GetInt() > 0) {
            String logHeader = "";
        
            if (kind == LT_ERROR)
                logHeader = "\cr[ERROR]";
                
            else if (kind == LT_WARNING)
                logHeader = "\cf[WARNING]";
                
            else if (kind == LT_INFO)
                logHeader = "\ch[INFO]";
                
            else if (kind == LT_VERBOSE) {
                if (CVar.FindCVar("zb_debug").GetInt() > 1)
                    logHeader =	"\cd[VERBOSE]";
                
                else
                    return;
            }
        
            A_Log("\cq[ZetaBot] "..logHeader.." "..msg);
        }
    }
    
    override void PostBeginPlay() {
        Super.PostBeginPlay();

        bool bHasNode;
        let ni = ThinkerIterator.create("ZTPathNode", 91);
        
        if (ni.Next())
            bHasNode = true;
            
        if (!bHasNode && CVar.FindCVar("nodelist").GetString() != "::NONE")
            ZTPathNode.plopNodes(CVar.FindCVar("nodelist").GetString());
            
        DebugLog(LT_VERBOSE, "Serialized Nodes: "..ZTPathNode.serializeLevel());
    
        ZTBotController cont = ZTBotController(Spawn("ZTBotController", pos));
        
        if (cont == null)
            return;
        
        cont.possessed.angle = angle;
        
        DebugLog(LT_INFO, "ZetaBot spawned with success! Class: "..cont.possessed.GetClassName());
        Destroy();

        let piter = ThinkerIterator.create("PlayerPawn");
        PlayerPawn pn;

        while (pn = PlayerPawn(piter.Next())) {
            DebugLog(LT_INFO, "Possessing a "..pn.GetClassName());
            ZetaSpiritEyes zse = ZetaSpiritEyes(Spawn("ZetaSpiritEyes"));
            zse.SetPlayer(pn);
            zse.possessed = cont.possessed;
            zse.cont = cont;
        }
    }
}

class ZetaSpiritEyes : Actor {
    ZetaBotPawn possessed;
    ZTBotController cont;
    PlayerPawn playa;

    void SetPlayer(PlayerPawn pn) {
        FreePlayer();

        playa = pn;
        playa.bInvisible = true;
        playa.bSolid = false;
        playa.bShootable = false;
    }

    void FreePlayer() {
        if (playa == null) return;
        
        playa.bInvisible = false;
        playa.bSolid = true;
        playa.bShootable = true;

        playa = null;
    }

    override void Tick() {
        if (cont == null || cont.possessed == null || possessed == null || possessed.Health <= 0) {
            FreePlayer();
            Destroy();
        }

        if (playa != null) {
            playa.SetXYZ(possessed.pos);
            playa.angle = possessed.angle;
            playa.health = possessed.health;
            if (cont.enemy == null) playa.pitch = 0;
            else playa.pitch = cont.PitchTo(cont.enemy);
        }
    }

    states {
        Spawn:
            TNT1 A 1;
            Goto TickLoop;
            
        TickLoop:
            TNT1 A 1;
            Loop;
    }
}

class BotName : Inventory {
    int countDown;
    bool printing;
    Actor lastShown;

    override void BeginPlay() {
        super.BeginPlay();
        countDown = 0;
    }
    
    override void Tick() {
        bool showing = false;

        if (countDown < 1) {
            let iter = ThinkerIterator.Create("ZetaBotPawn", STAT_DEFAULT);
            ZetaBotPawn zb = null;
            ZetaBotPawn closest = null;
            double cdist = 0;
            
            while (zb = ZetaBotPawn(iter.Next())) {
                Vector2 v1 = AngleToVector(Owner.angle);
                Vector2 v2 = Owner.Vec2To(zb) / Owner.Distance2D(zb);
                
                double vdot = (v1.x * v2.x + v1.y * v2.y);
                
                if (vdot > 1 - 1 / (Owner.Distance2D(zb) / (zb.Radius + 4)) && Owner.CheckSight(zb) && zb.cont != null && zb.Health > 0 && (closest == null || Owner.Distance2D(zb) < cdist)) {
                    cdist = Owner.Distance2D(zb);
                    closest = zb;
                }
            }
            
            if (closest != null && closest.cont != null) {
                countDown = 2;
                Owner.A_Print("\ci"..closest.cont.myName.."\n\cg"..closest.Health.." HP"..(
                    (
                        (closest.cont.bstate != ZTBotController.BS_ATTACKING || closest.cont.enemy == null)
                        ? "\n\cc"..ZTBotController.BStateNames[closest.cont.bstate]
                        : "\n\n\crAttacking a "..closest.cont.enemy.GetClassName().." with "..closest.cont.enemy.health.." HP!"
                    ).."\n\n"..(
                        closest.cont.currentOrder == null ? "\ccNo orders\cr"
                        : String.format("\crOrdered by %s; currently \cc", (
                            ZetaBotPawn(closest.cont.currentOrder.orderer) != null
                            ? ZetaBotPawn(closest.cont.currentOrder.orderer).cont.myName
                            : "a "..closest.cont.currentOrder.orderer.GetClassName()
                        ))..(closest.cont.currentOrder.v_continuous)..(
                            !(closest.cont.currentOrder.lookedAt != null && closest.cont.currentOrder.orderType != ZTBotController.BS_WANDERING) ? ""
                            : String.Format(" a %s with %d HP", closest.cont.enemy.GetClassName(), closest.cont.enemy.health)
                        ).."...\cr"
                    ).."\n"..(
                        closest.cont.commander == null ? "\crNo commander"
                        : "Commander: "..(
                            ZetaBotPawn(closest.cont.commander) != null
                            ? ZetaBotPawn(closest.cont.commander).cont.myName
                            : "a "..closest.cont.commander.GetClassName()
                        )
                    )
                ));
                lastShown = closest;
                printing = true;
            }

            ZTPathNode pnClosest;
            
            if (closest == null && CVar.FindCVar("zb_debug").GetInt() >= 2) {
                let nodeIter = ThinkerIterator.Create("ZTPathnode", 91);
                ZTPathNode pn;
                double pcdist;

                while (pn = ZTPathNode(nodeIter.Next())) {
                    Vector2 v1 = AngleToVector(Owner.angle);
                    Vector2 v2 = Owner.Vec2To(pn) / Owner.Distance2D(pn);
                    
                    double vdot = (v1.x * v2.x + v1.y * v2.y);
                    
                    if (vdot > 1 - 1 / (Owner.Distance2D(pn) / (pn.Radius + 4)) && Owner.CheckSight(pn) && (pnClosest == null || Owner.Distance2D(pn) < pcdist)) {
                        pcdist = Owner.Distance2D(pn);
                        pnClosest = pn;
                    }
                }
                
                if (pnClosest != null && pnClosest != lastShown) {
                    countDown = 2;
                    if (!printing) Owner.A_Print(String.Format("\ci%s Node: \cr#%i \cg(x=%d, y=%d)", ZTPathNode.ZTNavTypeNames[pnClosest.nodeType], pnClosest.id, pnClosest.pos.x, pnClosest.pos.y));
                    printing = true;
                    lastShown = pnClosest;
                }
            }

            if (pnClosest != null || closest != null) showing = true;
                
            if (!showing) {
                if (printing) Owner.A_Print("");

                printing = false;
                lastShown = null;
                countDown = 6;
            }
        }
            
        else
            countDown--;
    }
}