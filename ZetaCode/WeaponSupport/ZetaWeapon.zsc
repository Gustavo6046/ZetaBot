class ZetaWeapon : Actor
{
	property FireInterval: interval;
	property AltFireInterval: altinterval;
	property MinAmmo: minammo;
	property AmmoType: ammotype;
	property AltMinAmmo: altminammo;
	property AltAmmoType: altammotype;
    property AmmoUse: ammouse;
    property AltAmmoUse: altammouse;        
	
	int interval;
	int altinterval;
	int minammo;
	string ammotype;
	int altminammo;
	string altammotype;
    int ammouse;
    int altammouse;
	
	default
	{
		ZetaWeapon.FireInterval 10000000;
		ZetaWeapon.AltFireInterval 10000000;
		ZetaWeapon.MinAmmo 0;
		ZetaWeapon.AltMinAmmo 0;
        ZetaWeapon.AmmoUse 1;
        ZetaWeapon.AltAmmoUse 1;
		ZetaWeapon.AmmoType "Clip";
		ZetaWeapon.AltAmmoType "Clip";
	}
	
	static double RandomAngle(double range, double pivot = 0)
	{
        return FRandom(-range, range) + pivot;
	}

	virtual bool IsPickupOf(Weapon other)
	{
		return false;
	}
	
	virtual bool bHasAltFire(Actor shooter)
	{
		return true;
	}
	
	virtual double RateSelf(Actor shooter, Actor target)
	{
		return 0;
	}
	
	virtual double AltRateSelf(Actor shooter, Actor target)
	{
		return -1;
	}

	double GetRating(Actor shooter, Actor target)
	{
		if (target == null) return FRandom(0, 20);
		return RateSelf(shooter, target);
	}
	
	double GetAltRating(Actor shooter, Actor target)
	{
		if (target == null) return FRandom(0, 20);
		return AltRateSelf(shooter, target);
	}
	
	virtual bool CanFireAmmo(Actor shooter)
	{
		return true;
	}

	virtual bool CanFire(Actor shooter, bool bUseAmmo = false)
	{
		Inventory inv = shooter.FindInventory(ammotype);

		if ( inv == null )
			return minammo <= 0;
			
		else
		{
			if ( bUseAmmo && inv.amount >= minammo )
			{
				inv.amount -= minammo;
				return true;
			}

			return inv.amount >= minammo;
		}
	}
	
	virtual bool CanAltFire(Actor shooter, bool bUseAmmo = false)
	{
        if ( !bHasAltFire(shooter) )
            return false;
    
		Inventory inv = shooter.FindInventory(altammotype);
		
		if ( inv == null )
			return altminammo <= 0;
		
		else
		{
			if ( bUseAmmo && inv.amount >= altminammo )
			{
				inv.amount -= altminammo;
				return true;
			}

			return inv.amount >= altminammo;
		}
	}
	
	virtual double IntervalSeconds()
	{
		return 1. * interval / 10000000;
	}
	
	virtual double AltIntervalSeconds()
	{
		return 1. * altinterval / 10000000;
	}
	
	virtual void Fire(Actor shooter, Actor target) {}
	virtual void AltFire(Actor shooter, Actor target) {}
	
	virtual bool IsMelee()
	{
		return false;
	}
}


// For DECORATE users.
class ZTMyWeapon : ZetaWeapon {
	bool bZT_SPLASHDANGER;
	bool bZT_HASALT;
	bool bZT_MELEE;
	bool bZT_ALTMELEE;
	bool bZT_HITSCAN;
	bool bZT_ALTHITSCAN;

	double DangerRadius;
	double MeleeDamage;
	double AltMeleeDamage;
	class<Actor> MissileType;
	class<Actor> AltMissileType;
	class<Weapon> WeaponType;
	double BulletMinDamage;
	double BulletMaxDamage;
	double AltBulletMinDamage;
	double AltBulletMaxDamage;
	double BaseRating;
	double AltBaseRating;
	double DangerRating;
	double BulletSpreadH;
	double AltBulletSpreadH;
	double BulletSpreadV;
	double AltBulletSpreadV;
	double DangerFactor;

	property MissileType: MissileType;
	property AltMissileType: MissileType;
	property MeleeDamage: MeleeDamage;
	property AltMeleeDamage: AltMeleeDamage;
	property BulletMinDamage: BulletMinDamage;
	property BulletMaxDamage: BulletMaxDamage;
	property AltBulletMinDamage: AltBulletMinDamage;
	property AltBulletMaxDamage: AltBulletMaxDamage;
	property BaseRating: BaseRating;
	property AltBaseRating: AltBaseRating;
	property DangerRating: DangerRating;
	property DangerRadius: DangerRadius;
	property WeaponType: WeaponType;
	property BulletSpreadH: BulletSpreadH;
	property AltBulletSpreadH: AltBulletSpreadH;
	property BulletSpreadV: BulletSpreadV;
	property AltBulletSpreadV: AltBulletSpreadV;
	property DangerFactor: DangerFactor;

	default {
		ZTMyWeapon.DangerRadius 128;
		ZTMyWeapon.MeleeDamage 3;
		ZTMyWeapon.AltMeleeDamage 5;
		ZTMyWeapon.MissileType "Rocket";
		ZTMyWeapon.AltMissileType "Rocket";
		ZTMyWeapon.BulletMinDamage 2;
		ZTMyWeapon.BulletMaxDamage 5;
		ZTMyWeapon.AltBulletMinDamage 3;
		ZTMyWeapon.AltBulletMaxDamage 7;
		ZTMyWeapon.BaseRating 500;
		ZTMyWeapon.DangerRating 300;
		ZTMyWeapon.BulletSpreadH 10;
		ZTMyWeapon.AltBulletSpreadH 10;
		ZTMyWeapon.BulletSpreadV 3;
		ZTMyWeapon.AltBulletSpreadV 3;
		ZTMyWeapon.DangerFactor 2.25;
	}

	override bool IsPickupOf(Weapon other)
	{
		return other.GetClass() == WeaponType;
	}
	
	override bool bHasAltFire(Actor shooter)
	{
		return bZT_HASALT;
	}
	
	override double RateSelf(Actor shooter, Actor target)
	{
		if ( bZT_SPLASHDANGER && shooter.Distance3D(target) < DangerRadius )
			return DangerRating - shooter.Distance3D(target) * DangerFactor;
	
		return BaseRating / sqrt(shooter.Distance2D(target)) * 2;
	}

	override double AltRateSelf(Actor shooter, Actor target)
	{
		if ( bZT_SPLASHDANGER && shooter.Distance3D(target) < DangerRadius )
			return DangerRating - shooter.Distance3D(target) * DangerFactor;
	
		return AltBaseRating / sqrt(shooter.Distance2D(target)) * 2;
	}
	
	override void Fire(Actor shooter, Actor target)
	{
		if (bZT_MELEE)
			shooter.LineAttack(shooter.angle, 32, 0, MeleeDamage * FRandom(1, 8), "Punch", "BulletPuff", 0);

		else if (bZT_HITSCAN)
		ZetaBullet.FireABullet(shooter, "Gold", target, random(BulletMinDamage, BulletMaxDamage), BulletSpreadH, BulletSpreadV);

		else
			shooter.SpawnMissileAngle(MissileType, shooter.angle, target == null ? 0 : ((target.pos.z - shooter.pos.z) * 20 / target.Distance2D(shooter)));
	}

	override void AltFire(Actor shooter, Actor target)
	{
		if (bZT_MELEE)
			shooter.LineAttack(shooter.angle, 32, 0, AltMeleeDamage * FRandom(1, 8), "Punch", "BulletPuff", 0);

		else if (bZT_ALTHITSCAN)
			ZetaBullet.FireABullet(shooter, "Gold", target, random(AltBulletMinDamage, AltBulletMaxDamage), AltBulletSpreadH, AltBulletSpreadV);

		else
			shooter.SpawnMissileAngle(ALtMissileType, shooter.angle, target == null ? 0 : ((target.pos.z - shooter.pos.z) * 20 / target.Distance2D(shooter)));
	}
}
