class PlopResult : Thinker {
    uint totalNodes;
    Array<String> mapsFound;
    Array<String> nodeMaps;
	bool found;
}

class PathMarker : Actor {
    Default {
	    Scale 0.2;
	    RenderStyle "Add";
	    Alpha 0.7;
	    Radius 2;
	    Height 2;
	    Gravity 0;
    }

    States {
	    Spawn:
		    CAND A 200 Bright;
		    CAND A 20;
		    MISL CDE 5;
		    Stop;
    }
}

class ZTPositionMarker : Actor {
    Default
    {
        Scale 0.2;
        Height 16;
        Radius 18;
        Alpha 0.175;
        RenderStyle "Translucent";
    }

    override void Tick() {
        if ( CVar.FindCVar("zb_debug").GetInt() < 1 )
		    SetStateLabel("DLoop");
		
        else {
            angle += 18;
            SetStateLabel("DVisible");
        }

        Super.Tick();
    }

    States {
	    Spawn:
		    TNT1 A 0;
		    Goto DLoop;
		
	    DLoop:
		    TNT1 A 2;
		    Loop;
		
	    DVisible:
		    NODE A 2 Bright;
		    Loop;
    }
}

class NumNodes : Thinker {
    uint value;

    NumNodes Init() {
        ChangeStatNum(STAT_INFO);
        value = 0;
        return self;
    }

    static NumNodes Get() {
        ThinkerIterator it = ThinkerIterator.Create("NumNodes", STAT_INFO);
        let p = NumNodes(it.Next());
        
        if (p == null)
            p = new("NumNodes").Init();
        
        return p;
    }

    static uint Increment() {
	    NumNodes res = Get();
	    return ++res.value;
    }
}

class ZTPathNode : ZTPositionMarker
{
    enum NavigationType
    {
	    NT_NORMAL = 0,
	    NT_USE,
	    NT_SLOW,
	    NT_CROUCH,
	    NT_JUMP,
	    NT_AVOID,
	    NT_SHOOT,
	    NT_RESPAWN,
	    NT_TARGET
    };

    static const string ZTNavTypeNames[] = {
        "Normal",
        "Use",
        "Slow",
        "Crouch",
        "Jump",
        "Avoid",
        "Shoot",
        "Respawn",
        "Target"
    };

    enum LogType
    {
	    LT_ERROR = 0,
	    LT_WARNING,
	    LT_INFO,
	    LT_VERBOSE
    };

    void DebugLog(LogType kind, string msg)
    {
	    if ( CVar.FindCVar("zb_debug").GetInt() > 0 )
	    {
		    string logHeader = "";
	
		    if ( kind == LT_ERROR )
			    logHeader = "\cr[ERROR]";
			
		    else if ( kind == LT_WARNING )
			    logHeader = "\cf[WARNING]";
			
		    else if ( kind == LT_INFO )
			    logHeader = "\ch[INFO]";
			
		    else if ( kind == LT_VERBOSE )
		    {
			    if ( CVar.FindCVar("zb_debug").GetInt() > 1 )
				    logHeader =	"\cd[VERBOSE]";
			
			    else
				    return;
		    }
	
		    A_Log("\cq[ZetaBot] "..logHeader.." "..msg);
	    }
    }

    NavigationType nodeType;
    double useDirection;
    bool bPlopped;
    uint id;

    override void BeginPlay()
    {
	    Super.BeginPlay();
	
	    id = NumNodes.Increment();
        ChangeStatNum(91);
    }

    override void PostBeginPlay()
    {
	    super.PostBeginPlay();
	
	    DebugLog(LT_VERBOSE, String.format("Created node #%i at x=%f,y=%f", id, pos.x, pos.y));
    }

    static uint sindex(String full, String sub)
    {
	    uint i = 0;
	
	    while ( i < full.Length() - sub.Length() )
		    if ( full.Mid(i, sub.Length()) == sub )
			    return i;
		
	    return full.Length();
    }

    string serialize()
    {
	    return int(pos.x)..","..int(pos.y)..","..int(pos.z)..","..nodeType..","..int(useDirection);
    }

    static string serializeAll(ActorList allNodes)
    {
	    String res = level.mapname.."::";
	
	    allNodes.iReset();
	    ZTPathNode node;
	
	    while ( node = ZTPathNode(allNodes.iNext()) )
		    res = res..node.serialize()..":";
		
	    return res;
    }

    static string serializeLevel()
    {
	    let iter = ThinkerIterator.create("ZTPathNode", 91);
	    ActorList list = new("ActorList");
	
	    ZTPathNode node = null;
	
	    while ( node = ZTPathNode(iter.Next()) )
		    if (node.nodeType != NT_TARGET)
			    list.push(node);
		
	    return serializeAll(list);
    }

    static String split(string other, string sep, uint index)
    {
	    String res = "";
	    uint si = 0;
	    uint i = 0;

	    while ( i < other.Length() )
	    {
		    if ( other.Mid(i, sep.Length()) == sep )
		    {
			    if ( si++ == index )
				    return res;
			
			    i += sep.Length();
		    }
			
		    else
		    {
			    if ( si == index )
				    res = res..other.CharAt(i);
			
			    i++;
		    }
	    }
	
	    if ( si == index )
		    return res;
	
	    return "";
    }

    static int pow(int x, int n)
    {
		int cn = n;
	    int y = 1;
		
	    while (cn-- > 0) y *= x;
	    return y;
    }

    static int SInt(String s)
    {
	    int num = 0;
	    uint i = 0;
	    int sign = 1;
	
	    while ( s.Left(1) == "-" )
	    {
		    sign *= -1;
		    s = s.Mid(1);
	    }
	
	    while ( i < s.Length() )
	    {
		    int code = s.CharCodeAt(i);
	
		    if ( code < 48 || code > 57 ) // Numeric ASCII codes.
			    return 0;
		
		    num += (code - 48) * pow(10, s.Length() - ++i);
	    }
	
	    return num * sign;
    }

    static PlopResult plopNodes(string code)
    {
	    uint i = 0;
	    string c, levelMap = "", ncode;
	    let res = new("PlopResult");
	
	    if (code == "::NONE" || code == "")
		    return res;
		
	    while (true)
	    {
		    string cmap = split((c = split(code, ";;", i++)), "::", 0);

		    if (cmap == "") {
				if (levelMap == "")
			    	return res;

				else
					break;
			}

		    res.mapsFound.Push(cmap);
		    res.nodeMaps.Push(c);
	
			if (c == "")
			    return res;

		    if (cmap.MakeUpper() == level.mapName.MakeUpper())
			    levelMap = split(c, "::", 1);
	    }

		res.found = true;
	    i = 0;
	
	    for (i = 0; (ncode = split(levelMap, ":", i)) != ""; i++)
	    {
		    double nx = SInt(split(ncode, ",", 0));
		    double ny = SInt(split(ncode, ",", 1));
		    double nz = SInt(split(ncode, ",", 2));
		    NavigationType nt = SInt(split(ncode, ",", 3));
		    double ud = SInt(split(ncode, ",", 4));
		
		    let node = ZTPathNode(Spawn("ZTPathNode", (nx, ny, nz)));
		    node.nodeType = nt;
		    node.bPlopped = true;
		
		    node.useDirection = ud;
			node.angle = ud;
		
		    res.totalNodes++;
	    }
	
	    return res;
    }

    double specialCost(actor Other) // mimicks UT99's NavigationPoint.SpecialCost(Pawn Other)
    {
	    if ( nodeType == NT_AVOID )
		    return 512;

	    return 0;
    }

    ActorList NeighborsOutward()
    {
	    ThinkerIterator iter = ThinkerIterator.create("ZTPathNode", 91);
	    ZTPathNode node = null;
	    let preRes = new("ActorList");
	    let res = new("ActorList");

	    while ( ( node = ZTPathNode(iter.Next()) ) != null )
		    if ( canConnect(node) ) {
			    preRes.Push(node);
		    }
	
	    for ( uint i = 0; i < preRes.Length(); i++ ) {
		    ZTPathNode preNeigh = ZTPathNode(preRes.get(i));

		    if ( postCanConnect(preNeigh, preRes) )
			    res.Push(preNeigh);
	    }
	
	    return res;
    }

	ActorList NeighborsInward()
    {
	    ThinkerIterator iter = ThinkerIterator.create("ZTPathNode", 91);
	    ZTPathNode node = null;
	    let preRes = new("ActorList");
	    let res = new("ActorList");

	    while ( ( node = ZTPathNode(iter.Next()) ) != null )
		    if ( node.canConnect(self) ) {
			    preRes.Push(node);
		    }
	
	    for ( uint i = 0; i < preRes.Length(); i++ ) {
		    ZTPathNode preNeigh = ZTPathNode(preRes.get(i));

		    if ( postCanConnect(preNeigh, preRes) )
			    res.Push(preNeigh);
	    }
	
	    return res;
    }

    String NodeName() {
	    return String.Format("#%i (x=%f,y=%f)", id, pos.x, pos.y);
    }

    ZTPathNode RandomNeighbor()
    {
	    ActorList nb = NeighborsOutward();
	
	    if ( nb.Length() < 1 )
		    return self;
	
	    return ZTPathNode(nb.get(Random(0, nb.Length() - 1)));
    }

    void ShowPath(ZTPathNode otherNode) {
	    uint maxSeg = 15; // constant
	
	    Vector3 offs;
	    offs.xy = AngleToVector(AngleTo(otherNode));
	    Vector3 allOffs;
	    allOffs.xy = AngleToVector(AngleTo(otherNode) + 90);
	
	    for (uint seg = 0; seg < maxSeg; seg++) {
		    double alpha = 1.0 * seg / maxSeg;
		    double scaled = alpha * Distance3D(otherNode);
		    Vector3 pmPos = pos + offs * scaled + allOffs;
		    pmPos.z += (otherNode.pos.z - pos.z) * alpha;

		    PathMarker pm = PathMarker(Spawn("PathMarker", pmPos));
		    //pm.pos.z = pm.floorz;
	    }
    }

    void ShowAllPaths() {
	    ActorList nb = NeighborsOutward();

	    for (uint i = 0; i < nb.Length(); i++) {
		    ZTPathNode neigh = ZTPathNode(nb.Get(i));
		    ShowPath(neigh);
	    }
    }

    ActorList findPathTo(ZTPathNode goal, Actor traveller = null)
    {
	    let res = ActorList.Empty();
		int itersLeft = 1000; // safety limit

	    if ( goal == null || goal == self )
	    {
		    res.push(self);
		    return res;
	    }

	    NumberDict icosts = new("NumberDict");
	    Dict cameFrom = new("Dict");
	    PriorityQueue openSet = new("PriorityQueue");
	    ActorList closedSet = new("ActorList");
	
	    bool foundGoal = false;
	
	    icosts.set(goal, 0);
	    openSet.add(goal, 0);
	
	    DebugLog(LT_VERBOSE, String.Format("> Pathfinding from %s to %s", NodeName(), goal.NodeName()));

	    while ( openSet.length() > 0 && --itersLeft )
	    {
		    ZTPathNode current = ZTPathNode(openSet.poll());
		     
		    if (closedSet.has(current)) continue;
		
		    DebugLog(LT_VERBOSE, String.Format("+-- Iterating pathfinding for node: %s", current.NodeName()));
		    ActorList nb = current.NeighborsInward();
	
		    for ( uint i = 0; i < nb.Length(); i++ ) {
			    ZTPathNode neigh = ZTPathNode(nb.get(i));
			    DebugLog(LT_VERBOSE, String.Format("+-+-- Considering #%i's neighbor: %s", current.id, neigh.NodeName()));

			    if (!(openSet.has(neigh) || closedSet.has(neigh)))
			    {
				    cameFrom.set(current, neigh);

					if (neigh == self)
					{
						DebugLog(LT_VERBOSE, String.Format("  '-- # Goal node #%i found!", neigh.id));
						foundGoal = true;
						break;
					}

				    double icost = icosts.get(current, 0) + goal.Distance3D(neigh);
				    double cost = neigh.Distance3D(self) + icost + neigh.specialCost(traveller);
			
				    icosts.set(neigh, icost);
				    openSet.add(neigh, cost);
			    }
		    }
			
		    closedSet.push(current);
	    }
	
	    if ( !foundGoal ) {
			if (!itersLeft)
				DebugLog(LT_WARNING, String.Format("Infinite recursion attempting to find a path betwen %s and %s", NodeName(), goal.NodeName()));

		    return null;
		}
		
	    ZTPathNode cur = goal;
		ZTPathNode pcur;
	
	    while (cur != self)
	    {
			if (cur == null) {
				break;
			}

		    res.insert(0, cur);
			pcur = cur;
		    cur = ZTPathNode(cameFrom.get(Object(cur)));
			// DebugLog(LT_VERBOSE, String.Format("%i -> %i", (cur == null ? -1 : cur.id), (pcur == null ? -1 : pcur.id)));

			if (pcur == cur) {
				break;
			}
	    }
	
	    DebugLog(LT_INFO, String.format("Found a %i-node path between %s and %s!", (res.Length() + 1), NodeName(), goal.NodeName()));
	
	    return res;
    }

    static ZTPathNode plopNode(Vector3 position, NavigationType nt, float angle = 0)
    {
	    let node = ZTPathNode(Spawn("ZTPathNode", position));
	    node.nodeType = nt;
	    node.angle = angle;
	
	    return node;
    }

    bool PostCanConnect(ZTPathNode next, ActorList preNeighbors)
    {
	    if (next.nodeType == NT_AVOID)
		    return preNeighbors.Length() < 2;

	    ZTPathNode pn = null;

		let dist = Distance3D(next);
	    let off1 = Vec3To(next) / dist;
	
	    for ( uint i = 0; i < preNeighbors.Length(); i++ )
	    {
		    ZTPathNode pn = ZTPathNode(preNeighbors.get(i));
		
		    if (pn != self && pn != next && pn.Distance3D(next) < dist - 32) {
			    let off2 = Vec2To(pn) / Distance2D(pn);

			    if ((off1.x * off2.x + off1.y * off2.y) > 0.85)
				    return false; // there is already a shorter path in the same
							      // direction
		    }
	    }

	    return true;
    }

    bool CanConnect(ZTPathNode next)
    {
        if ( next == null )
            return false;

	    if ((nodeType == NT_USE || next.nodeType == NT_USE) && Distance2D(next) < 64)
		    return true; // for doors that block LOS but are traverseable, etc.

	    double maxZDiff = 48;
	    double minDist = 64;

	    if ( next.nodeType == NT_JUMP || nodeType == NT_JUMP )
		    maxZDiff = 60;
		
	    if ( next.nodeType == NT_SLOW || nodeType == NT_SLOW || next.nodeType == NT_CROUCH || nodeType == NT_CROUCH )
		    minDist = 32;
		
	    else if ( next.nodeType == NT_USE || nodeType == NT_USE )
		    minDist = 4;
		
	    minDist -= abs(next.pos.z - pos.z) * 0.5;
	
	    if ( minDist <= 0 )
		    return false;
		
	    if ( Distance3D(next) < minDist )
		    return false;
		
	    double diffZ = next.pos.z - pos.z;
		
	    if ( diffZ > maxZDiff )
		    return false;
	
	    // experimental
	    if (CheckBlock(
		    xofs: next.pos.x - pos.x,
		    yofs: next.pos.y - pos.y,
		    zofs: next.pos.z - pos.z,
		    angle: AngleTo(next)
	    )) return false;

	    if (!CheckSight(next)) {
		    FLineTraceData sight;
		    LineTrace(AngleTo(next), Distance2D(next), PitchTo(next, 40), TRF_THRUACTORS | TRF_THRUHITSCAN, 40, data: sight);

		    if (sight.HitType == TRACE_HITWALL)
			    return false;
	    }

	    return true;
    }

    double PitchTo(Actor other, double offsZ = 0) {
        if (other == null)
            return 0;

        if (other.pos.z + other.height / 2 == pos.z + height / 2 + offsZ) return 0;

        //return offsZ + other.pos.z + other.height / 2 - pos.z - height / 2;
        return tan(offsZ + other.pos.z + other.height / 2 - pos.z - height / 2);
    }
}

class ZTUseNode : Actor
{
    override void PostBeginPlay()
    {
	    let node = ZTPathNode(Spawn("ZTPathNode", pos));
	    node.nodeType = ZTPathNode.NT_USE;
	    node.useDirection = angle;
	    node.angle = angle;
	
	    Destroy();
    }
}

class ZTJumpNode : Actor
{
    override void PostBeginPlay()
    {
	    let node = ZTPathNode(Spawn("ZTPathNode", pos));
	    node.nodeType = ZTPathNode.NT_JUMP;
	    node.angle = angle;
	
	    Destroy();
    }
}

class ZTSlowNode : Actor
{
    override void PostBeginPlay()
    {
	    let node = ZTPathNode(Spawn("ZTPathNode", pos));
	    node.nodeType = ZTPathNode.NT_SLOW;
	    node.angle = angle;
	
	    Destroy();
    }
}

class ZTCrouchNode : Actor
{
    override void PostBeginPlay()
    {
	    let node = ZTPathNode(Spawn("ZTPathNode", pos));
	    node.nodeType = ZTPathNode.NT_CROUCH;
	    node.angle = angle;
	
	    Destroy();
    }
}

class ZTShootNode : Actor
{
    override void PostBeginPlay()
    {
	    let node = ZTPathNode(Spawn("ZTPathNode", pos));
	    node.nodeType = ZTPathNode.NT_SHOOT;
	    node.angle = angle;
	
	    Destroy();
    }
}


class ZTAvoidNode : Actor
{
    override void PostBeginPlay()
    {
	    let node = ZTPathNode(Spawn("ZTPathNode", pos));
	    node.nodeType = ZTPathNode.NT_AVOID;
	    node.angle = angle;
	
	    Destroy();
    }
}

class ZTUploadNodes : Actor
{
    override void BeginPlay()
    {
	    //String code = ZTPathNode.uploadLevel();
        uploadLevel(CVar.FindCVar("zb_nodevar").GetString());
	    // A_PrintBold("'"..code.."'");
	
	    Destroy();
	}
    
    static void uploadLevel(String cvName)
    {
        if (CVar.FindCVar(cvName) == null)
            return;

	    String code = CVar.FindCVar(cvName).GetString();
		
	    if ( code == "::NONE" || code == "" )
		    code = ZTPathNode.serializeLevel();
	
	    else
	    {
		    String c = "";
		    uint i = 0;
	
		    while ( true )
		    {
                c = ZTPathNode.split(code, ";;", i++);
		
			    if ( ZTPathNode.split(c, "::", 0) == level.mapName)
				    break;
				
			    if ( c == "" )
			    {
                    code = ZTPathNode.serializeLevel()..";;"..code;
				    CVar.FindCVar(cvName).SetString(code);
				    return;
			    }
		    }
		
		    code = code.Left(ZTPathNode.sindex(code, c))..ZTPathNode.serializeLevel()..code.Mid(ZTPathNode.sindex(code, c) + c.Length());
	    }
	
	    CVar.FindCVar(cvName).SetString(code);
    }
}

class ZTPromptNodes : Actor
{
	bool CheckLumpName(int lump, string name) {
		A_Log(String.Format("%i -> %s = %i", lump, name, Wads.FindLump(name, lump, 1)));
		return Wads.FindLump(name, lump, 1) == lump;
	}

	enum LogType
    {
	    LT_ERROR = 0,
	    LT_WARNING,
	    LT_INFO,
	    LT_VERBOSE
    };

	void DebugLog(LogType kind, string msg)
    {
	    if ( CVar.FindCVar("zb_debug").GetInt() > 0 )
	    {
		    string logHeader = "";
	
		    if ( kind == LT_ERROR )
			    logHeader = "\cr[ERROR]";
			
		    else if ( kind == LT_WARNING )
			    logHeader = "\cf[WARNING]";
			
		    else if ( kind == LT_INFO )
			    logHeader = "\ch[INFO]";
			
		    else if ( kind == LT_VERBOSE )
		    {
			    if ( CVar.FindCVar("zb_debug").GetInt() > 1 )
				    logHeader =	"\cd[VERBOSE]";
			
			    else
				    return;
		    }
	
		    A_Log("\cq[ZetaBot] "..logHeader.." "..msg);
	    }
    }

	PlopResult ReadZBNodes() {
		for (int startLump = Wads.FindLump(level.mapname, 0, 1); startLump != -1; startLump = Wads.FindLump(level.mapname, startLump + 1, 1)) {
			int mapLump = startLump + 1;

			CheckLumpName(mapLump, level.mapname);
			while (
				CheckLumpName(mapLump, "THINGS") ||
				CheckLumpName(mapLump, "LINEDEFS") ||
				CheckLumpName(mapLump, "SIDEDEFS") ||
				CheckLumpName(mapLump, "VERTEXES") ||
				CheckLumpName(mapLump, "SEGS") ||
				CheckLumpName(mapLump, "SSECTORS") ||
				CheckLumpName(mapLump, "NODES") ||
				CheckLumpName(mapLump, "SECTORS") ||
				CheckLumpName(mapLump, "REJECT") ||
				CheckLumpName(mapLump, "BLOCKMAP") ||
				CheckLumpName(mapLump, "BEHAVIOR") ||
				CheckLumpName(mapLump, "SCRIPTS") ||
				CheckLumpName(mapLump, "ENDMAP") ||
				CheckLumpName(mapLump, "ZNODES") ||
				CheckLumpName(mapLump, "TEXTMAP")
			) {
				if (CheckLumpName(++mapLump, "ZBNODES"))
					break;
			}

			if (!CheckLumpName(mapLump, "ZBNODES"))
				continue;

			A_Log(String.Format("Found ZBNODES @ %i", mapLump));

			return ZTPathNode.plopNodes(Wads.ReadLump(mapLump));
		}

		return null;
	}

    override void BeginPlay()
    {
	    ZTPathNode n;
	    let iter = ThinkerIterator.Create("ZTPathNode", 91);
	
	    while ( n = ZTPathNode(iter.Next()) )
		    n.Destroy();
	
	    cvar cv = CVar.FindCVar(CVar.FindCVar("zb_nodevar").GetString());
	
		PlopResult r;

	    if ( cv == null )
	    {
			if (!(r = ReadZBNodes())) return;
        }
	
		else {
	    	r = ZTPathNode.plopNodes(cv.GetString());

			if (r.totalNodes == 0) {
				r = ReadZBNodes();

				if (!r || !r.found) {
					string lst = String.format("No nodes found (\"%s\")! %i maps found", level.mapName, r.mapsFound.Size(0));

					for ( uint i = 0; i < r.mapsFound.Size(); i++ )
		    			lst = lst.."  \""..r.mapsFound[i].."\"";

					A_Log(lst);
					Destroy();
					
					return;
				}
			}
		}

	    string lst = r.totalNodes.." nodes plopped! "..r.mapsFound.Size().." maps found in nodelist:";
	
	    for ( uint i = 0; i < r.mapsFound.Size(); i++ )
		    lst = lst.."  \""..r.mapsFound[i].."\"";

	    A_Log(lst);
	    Destroy();
    }
}

class ZTDeleteNodes : Actor
{
    override void BeginPlay()
    {
	    ZTPathNode n;
	    let iter = ThinkerIterator.Create("ZTPathNode", 91);
	    String logged = "Deleted %u nodes.";
	    uint count = 0;
	
	    while ( n = ZTPathNode(iter.Next()) ) {
		    n.Destroy();
		    count++;
	    }

	    A_Log(String.Format(logged, count));
	    Destroy();
    }
}

class ZTShowAllPaths : Actor {
    override void BeginPlay() {
	    ZTPathNode n;
	    let iter = ThinkerIterator.Create("ZTPathNode", 91);
	
	    while (n = ZTPathNode(iter.Next()))
		    n.ShowAllPaths();

	    Destroy();
    }
}
