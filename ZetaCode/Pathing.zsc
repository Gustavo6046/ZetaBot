class PlopResult : Thinker
{
	uint totalNodes;
	Array<String> mapsFound;
	Array<String> nodeMaps;
}

class ZTPositionMarker : Actor {
	Default
	{
        Scale 0.2;
        Height 16;
        Radius 18;
        Alpha 0.175;
        RenderStyle "Translucent";
	}

	override void Tick() {
        if ( CVar.FindCVar("zb_debug").GetInt() < 1 )
			SetStateLabel("DLoop");
			
        else {
            angle += 18;
            SetStateLabel("DVisible");
        }

        Super.Tick();
    }
	
	States {
		Spawn:
			TNT1 A 0;
			Goto DLoop;
			
		DLoop:
			TNT1 A 2;
			Loop;
			
		DVisible:
			NODE A 2 Bright;
			Loop;
	}
}

class NumNodes : Thinker {
    uint value;

    NumNodes Init() {
        ChangeStatNum(STAT_INFO);
        value = 0;
        return self;
    }

    static NumNodes Get() {
        ThinkerIterator it = ThinkerIterator.Create("NumNodes", STAT_INFO);
        let p = NumNodes(it.Next());
        
        if (p == null)
            p = new("NumNodes").Init();
        
        return p;
    }

	static uint Increment() {
		NumNodes res = Get();
		return ++res.value;
	}
}

class ZTPathNode : ZTPositionMarker
{
	enum NavigationType
	{
		NT_NORMAL = 0,
		NT_USE,
		NT_SLOW,
		NT_CROUCH,
		NT_JUMP,
		NT_AVOID,
		NT_SHOOT,
		NT_RESPAWN,
		NT_TARGET
	};

	static const string ZTNavTypeNames[] = {
        "Normal",
        "Use",
        "Slow",
        "Crouch",
        "Jump",
        "Avoid",
        "Shoot",
        "Respawn",
        "Target"
    };

	enum LogType
	{
		LT_ERROR = 0,
		LT_WARNING,
		LT_INFO,
		LT_VERBOSE
	};

	void DebugLog(LogType kind, string msg)
	{
		if ( CVar.FindCVar("zb_debug").GetInt() > 0 )
		{
			string logHeader = "";
		
			if ( kind == LT_ERROR )
				logHeader = "\cr[ERROR]";
				
			else if ( kind == LT_WARNING )
				logHeader = "\cf[WARNING]";
				
			else if ( kind == LT_INFO )
				logHeader = "\ch[INFO]";
				
			else if ( kind == LT_VERBOSE )
			{
				if ( CVar.FindCVar("zb_debug").GetInt() > 1 )
					logHeader =	"\cd[VERBOSE]";
				
				else
					return;
			}
		
			A_Log("\cq[ZetaBot] "..logHeader.." "..msg);
		}
	}

	NavigationType nodeType;
	double useDirection;
	bool bPlopped;
	uint id;
	
	override void BeginPlay()
	{
		Super.BeginPlay();
		
		id = NumNodes.Increment();
        ChangeStatNum(91);
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		
		DebugLog(LT_VERBOSE, String.format("Created node #%i at x=%f,y=%f", id, pos.x, pos.y));
	}
	
	static uint sindex(String full, String sub)
	{
		uint i = 0;
		
		while ( i < full.Length() - sub.Length() )
			if ( full.Mid(i, sub.Length()) == sub )
				return i;
			
		return full.Length();
	}
	
	string serialize()
	{
		return int(pos.x)..","..int(pos.y)..","..int(pos.z)..","..nodeType..","..int(useDirection);
	}
	
	static string serializeAll(ActorList allNodes)
	{
		String res = level.mapname.."::";
		
		allNodes.iReset();
		ZTPathNode node;
		
		while ( node = ZTPathNode(allNodes.iNext()) )
			res = res..node.serialize()..":";
			
		return res;
	}
	
	static string serializeLevel()
	{
		let iter = ThinkerIterator.create("ZTPathNode", STAT_DEFAULT);
		ActorList list = new("ActorList");
		
		ZTPathNode node = null;
		
		while ( node = ZTPathNode(iter.Next()) )
			if (node.nodeType != NT_TARGET)
				list.push(node);
			
		return serializeAll(list);
	}
	
	static String split(string other, string sep, uint index)
	{
		String res = "";
		uint si = 0;
		uint i = 0;
	
		while ( i < other.Length() )
		{
			if ( other.Mid(i, sep.Length()) == sep )
			{
				if ( si++ == index )
					return res;
				
				i += sep.Length();
			}
				
			else
			{
				if ( si == index )
					res = res..other.CharAt(i);
				
				i++;
			}
		}
		
		if ( si == index )
			return res;
		
		return "";
	}
	
	static int pow(int x, int n)
	{
		int y = 1;
		while (n-- > 0) y *= x;
		return y;
	}
	
	static int SInt(String s)
	{
		int num = 0;
		uint i = 0;
		int sign = 1;
		
		while ( s.Left(1) == "-" )
		{
			sign *= -1;
			s = s.Mid(1);
		}
		
		while ( i < s.Length() )
		{
			int code = s.CharCodeAt(i);
		
			if ( code < 48 || code > 57 ) // Numeric ASCII codes.
				return 0;
			
			num += (code - 48) * pow(10, s.Length() - ++i);
		}
		
		return num * sign;
	}
	
	static PlopResult plopNodes(string code)
	{
		uint i = 0;
		string c, levelMap, ncode;
		let res = new("PlopResult");
		
		if ( code == "::NONE" )
			return res;
			
		while ( true )
		{
			string cmap = split((c = split(code, ";;", i++)), "::", 0);

			if (cmap == "")
				break;

			res.mapsFound.Push(cmap);
			res.nodeMaps.Push(c);
		
			if ( cmap == level.mapName )
				levelMap = split(c, "::", 1);
				
			if ( c == "" )
				return res;
		}
				
		i = 0;
		
		for ( i = 0; (ncode = split(levelMap, ":", i)) != ""; i++ )
		{
			double nx = SInt(split(ncode, ",", 0));
			double ny = SInt(split(ncode, ",", 1));
			double nz = SInt(split(ncode, ",", 2));
			NavigationType nt = SInt(split(ncode, ",", 3));
			double ud = SInt(split(ncode, ",", 4));
			
			let node = ZTPathNode(Spawn("ZTPathNode", (nx, ny, nz)));
			node.nodeType = nt;
			node.bPlopped = true;
			
			node.useDirection = ud;
			
			res.totalNodes++;
		}
		
		return res;
	}
	
	double specialCost(actor Other) // mimicks UT99's NavigationPoint.SpecialCost(Pawn Other)
	{
		if ( nodeType == NT_AVOID )
			return 512;
	
		return 0;
	}
	
	ActorList Neighbors()
	{
		ThinkerIterator iter = ThinkerIterator.create("ZTPathNode", 91);
		ZTPathNode node = null;
		let preRes = new("ActorList");
		let res = new("ActorList");
	
		while ( ( node = ZTPathNode(iter.Next()) ) != null )
			if ( canConnect(node) ) {
				preRes.Push(node);
			}
		
		for ( uint i = 0; i < preRes.Length(); i++ ) {
			ZTPathNode preNeigh = ZTPathNode(preRes.get(i));

			if ( postCanConnect(preNeigh, preRes) )
				res.Push(preNeigh);
		}
		
		return res;
	}

	String NodeName() {
		return String.Format("#%i (x=%f,y=%f)", id, pos.x, pos.y);
	}
	
	ZTPathNode RandomNeighbor()
	{
		ActorList nb = Neighbors();
		
		if ( nb.Length() < 1 )
			return self;
		
		return ZTPathNode(nb.get(Random(0, nb.Length() - 1)));
	}
	
	ActorList findPathTo(ZTPathNode other, Actor traveller = null)
	{
		let res = ActorList.Empty();
	
		if ( other == null || other == self )
		{
			res.push(self);
			return res;
		}
	
		NumberDict icosts = new("NumberDict");
		Dict cameFrom = new("Dict");
		PriorityQueue openSet = new("PriorityQueue");
		ActorList closedSet = new("ActorList");
		
		bool foundGoal = false;
		
		icosts.set(self, 0);
		openSet.add(self, 0);
		
		DebugLog(LT_VERBOSE, String.Format("> Pathfinding to: %s", other.NodeName()));

		while ( openSet.length() > 0 )
		{
			ZTPathNode current = ZTPathNode(openSet.poll());
			 
			if (closedSet.has(current)) continue;

			if (current == other)
			{
				DebugLog(LT_VERBOSE, String.Format("Goal node #%i found!", current.id));
				foundGoal = true;
				break;
			}
			
			DebugLog(LT_VERBOSE, String.Format("+-- Iterating pathfinding for node: %s", current.NodeName()));
			ActorList nb = current.Neighbors();
		
			for ( uint i = 0; i < nb.Length(); i++ ) {
				ZTPathNode neigh = ZTPathNode(nb.get(i));
				DebugLog(LT_VERBOSE, String.Format("+-+-- Considering #%i's neighbor: %s", current.id, neigh.NodeName()));

				if (!(openSet.has(neigh) || closedSet.has(neigh)))
				{
					double icost = icosts.get(current, 0) + current.Distance3D(neigh);
					double cost = neigh.Distance3D(other) + icost + neigh.specialCost(traveller);
				
					icosts.set(neigh, icost);
					openSet.add(neigh, cost);
					cameFrom.set(neigh, current);
				}
			}
				
			closedSet.push(current);
		}
		
		if ( !foundGoal )
			return null;
			
		ZTPathNode cur = other;
		
		while ( cur != self )
		{
			res.insert(0, cur);
			cur = ZTPathNode(cameFrom.get(Object(cur)));
		}
		
		DebugLog(LT_INFO, String.format("Found a %i-node path between %s and %s!", (res.Length() + 1), NodeName(), other.NodeName()));
		
		return res;
	}
	
	static ZTPathNode plopNode(Vector3 position, NavigationType nt, float angle = 0)
	{
		let node = ZTPathNode(Spawn("ZTPathNode", position));
		node.nodeType = nt;
		node.angle = angle;
		
		return node;
	}
	
	bool PostCanConnect(ZTPathNode next, ActorList preNeighbors)
	{
		if (next.nodeType == NT_AVOID)
			return preNeighbors.Length() < 2;

		ZTPathNode pn = null;
		let off1 = Vec2To(next) / Distance2D(next);
		
		for ( uint i = 0; i < preNeighbors.Length(); i++ )
		{
			ZTPathNode pn = ZTPathNode(preNeighbors.get(i));
			
			if (pn != self && pn != next && pn.Distance2D(next) < Distance2D(next) - 32) {
				let off2 = Vec2To(pn) / Distance2D(pn);

				if ((off1.x * off2.x + off1.y * off2.y) > 0.8)
					return false; // there is already a shorter path in the same
								  // direction
			}
		}

		return true;
	}
	
	bool CanConnect(ZTPathNode next)
	{
        if ( next == null )
            return false;
	
		if ((nodeType == NT_USE || next.nodeType == NT_USE) && Distance2D(next) < 64)
			return true; // for doors that block LOS but are traverseable, etc.
	
		double maxZDiff = 24;
		double minDist = 64;
	
		if ( next.nodeType == NT_JUMP || nodeType == NT_JUMP )
			maxZDiff = 60;
			
		if ( next.nodeType == NT_SLOW || nodeType == NT_SLOW || next.nodeType == NT_CROUCH || nodeType == NT_CROUCH )
			minDist = 32;
			
		else if ( next.nodeType == NT_USE || nodeType == NT_USE )
			minDist = 4;
			
		minDist -= abs(next.pos.z - pos.z) * 0.5;
		
		if ( minDist <= 0 )
			return false;
			
		if ( Distance3D(next) < minDist )
			return false;
			
		double diffZ = next.pos.z - pos.z;
			
		if ( diffZ > maxZDiff )
			return false;
		
		if (!CheckSight(next) && LineTrace(AngleTo(next), Distance3D(next), PitchTo(next, 32), TRF_THRUACTORS | TRF_THRUHITSCAN, 32))
			return false;

		return true;
	}

	double PitchTo(Actor other, double offsZ = 0) {
        if (other == null)
            return 0;

        if (other.pos.z + other.height / 2 == pos.z + height / 2 + offsZ) return 0;

        return atan(offsZ + other.pos.z + other.height / 2 - pos.z - height / 2);
        //return offsZ + other.pos.z + other.height / 2 - pos.z - height / 2;
    }
}

class ZTUseNode : Actor
{
	override void PostBeginPlay()
	{
		let node = ZTPathNode(Spawn("ZTPathNode", pos));
		node.nodeType = ZTPathNode.NT_USE;
		node.useDirection = angle;
		node.angle = angle;
		
		Destroy();
	}
}

class ZTJumpNode : Actor
{
	override void PostBeginPlay()
	{
		let node = ZTPathNode(Spawn("ZTPathNode", pos));
		node.nodeType = ZTPathNode.NT_JUMP;
		node.angle = angle;
		
		Destroy();
	}
}

class ZTSlowNode : Actor
{
	override void PostBeginPlay()
	{
		let node = ZTPathNode(Spawn("ZTPathNode", pos));
		node.nodeType = ZTPathNode.NT_SLOW;
		node.angle = angle;
		
		Destroy();
	}
}

class ZTCrouchNode : Actor
{
	override void PostBeginPlay()
	{
		let node = ZTPathNode(Spawn("ZTPathNode", pos));
		node.nodeType = ZTPathNode.NT_CROUCH;
		node.angle = angle;
		
		Destroy();
	}
}

class ZTShootNode : Actor
{
	override void PostBeginPlay()
	{
		let node = ZTPathNode(Spawn("ZTPathNode", pos));
		node.nodeType = ZTPathNode.NT_SHOOT;
		node.angle = angle;
		
		Destroy();
	}
}


class ZTAvoidNode : Actor
{
	override void PostBeginPlay()
	{
		let node = ZTPathNode(Spawn("ZTPathNode", pos));
		node.nodeType = ZTPathNode.NT_AVOID;
		node.angle = angle;
		
		Destroy();
	}
}

class ZTUploadNodes : Actor
{
	override void BeginPlay()
	{
		//String code = ZTPathNode.uploadLevel();
        uploadLevel(CVar.FindCVar("zb_nodevar").GetString());
		// A_PrintBold("'"..code.."'");
		
		Destroy();
	}
    
    static void uploadLevel(String cvName)
	{
        if (CVar.FindCVar(cvName) == null)
            return;

		String code = CVar.FindCVar(cvName).GetString();
			
		if ( code == "::NONE" || code == "" )
			code = ZTPathNode.serializeLevel();
		
		else
		{
			String c;
			uint i = 0;
		
			while ( true )
			{
                c = ZTPathNode.split(code, ";;", i++);
			
				if ( ZTPathNode.split(c, "::", 0) == level.mapName)
					break;
					
				if ( c == "" )
				{
                    code = ZTPathNode.serializeLevel()..";;"..code;
					CVar.FindCVar(cvName).SetString(code);
					return;
				}
			}
			
			code = code.Left(ZTPathNode.sindex(code, c))..ZTPathNode.serializeLevel()..code.Mid(ZTPathNode.sindex(code, c) + c.Length());
		}
		
		CVar.FindCVar(cvName).SetString(code);
	}
}

class ZTPromptNodes : Actor
{
	override void BeginPlay()
	{
		ZTPathNode n;
		let iter = ThinkerIterator.Create("ZTPathNode", 91);
		
		while ( n = ZTPathNode(iter.Next()) )
			n.Destroy();
		
		cvar cv = CVar.FindCVar(CVar.FindCVar("zb_nodevar").GetString());
		
		if ( cv == null )
		{
            Destroy();
            return;
        }
		
		PlopResult r = ZTPathNode.plopNodes(cv.GetString());
		string lst = r.totalNodes.." nodes plopped! "..r.mapsFound.Size().." maps found in nodelist:";
		
		for ( uint i = 0; i < r.mapsFound.Size(); i++ )
			lst = lst.."  >"..r.mapsFound[i];
	
		A_Log(lst);
		Destroy();
	}
}

class ZTDeleteNodes : Actor
{
	override void BeginPlay()
	{
		ZTPathNode n;
		let iter = ThinkerIterator.Create("ZTPathNode", 91);
		String logged = "Deleted %u nodes.";
		uint count = 0;
		
		while ( n = ZTPathNode(iter.Next()) ) {
			n.Destroy();
			count++;
		}

		A_Log(String.Format(logged, count));
		Destroy();
	}
}
